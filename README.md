**<center>《Python入门到放弃》</center>**

**<center>-Designed by Questeryu Made in FuGu.China</center>**


**<center>2020/08/01—08/15(历时15Day）</center>**

# 软件安装与软件熟悉

## 写在前面



关于软件安装就自己去玩吧，如果你连这个自己都搞不懂，你不是不聪明，只是**没有强烈的求知欲望**（饥饿感）

如果安装过程中遇到什么问题or需要了解什么（Emall：Questeryu@qq.com）共同学习；


你也可以自己去互联网上面得到你任何想要的知识，互联网的出现，一定程度上消除了地域的限制！

同时内容难免会有其他疏漏等，请给予斧正

感谢网络时代能够给消除地域上的限制，使得资源得到共享，发挥更大的价值

当然我也可以将它写成一本书，将我的时间一次打包N次售卖！ 我还是认为把它分享给需要的人!

仅此感谢教我知识的人生老师 and Network！

学完编程后，编程不重要，重要的是思想，因为在做任何事情之前，我们首先要认识自己，编程只是手段仅此而已，

技术具有两面性，我希望技术是能够给人类带来幸福，创造新价值！**利他**，目的是服务于社会



**无论是来自于自然界，还是来自于社会，一次重大的危机or 灾难必定带来整个社会的变革，这不
仅包括国家和企业的崛起和消亡，也涉及人们的生活方式和价值观的改变。
从长远角度来看，淘汰掉不健康的公司未必是一件坏事，大量不健康的公司拉低了整个社会的投
资效率，经济变的死气沉沉，这些公司的消失，为健康的公司腾出了宝贵的市场空间，健康有活
力的公司将成为未来直接的受益者。——《浪潮之巅》**


## 教程参考：
最好的 Python 教程，是官方网站上的 The Python Tutorial

版本：for v.3.8.5


你必须要将概念彻底的刻在自己的脑中，就像我们吃饭一样，变成一种潜意识行为

这样你后期才能够专注与自己的模型设计，从而产出更多的东西 

中文版：https://docs.python.org/zh-cn/3/tutorial/index.html

English version：https://docs.python.org/3/tutorial/index.html（有能力建议阅读）

日本語バージョン：https://docs.python.org/ja/3/tutorial/index.html

## 关于文中未能解决的问题

解包参数列表

====================================

**list(range(3,6)**

**print(list(range(3,6)))**

====================================

这句代码在Jupyter Not book中运行不知到为什么通不过

而在Python自带的编译器中通过了  什么鬼？

## 关于学习


学习是一个愉快有趣的过程，你很难拒绝一个快乐的过程。如果你感到学习不是那样的，那并不是
知识本身的问题，而是汲取知识的开始出了问题。学习是一个自发的过程，你愿意为之付出，人们愿意
去做一件事情时，才会全力侵入心血把它做好。学习要放下所有对这件事的偏见，重新去认识它，像一
个Baby，保持一颗初心。所以你学不好的时候，不要去学了，先试着让自己喜欢上这件事情。你都不喜
欢，那些所谓的番茄工作法，真的有用吗？
Stay hungry，Stay foolish.(求知若饥，虚心若愚)——Steve Jobs(史蒂夫 乔布斯)
有的时候看似一些无关的东西没有，你也许知道学这些有什么用，但是就是喜欢。在生命的后期，
这些所谓你喜欢又不知道有什么用的东西，突然间会创造出一个新的事物！比如这次写文章（实则是我
看了好多好多书，才沉淀下一点点，少的可怜呐！），同时记录这些沉淀，我要进行排版、处理图片
（PS），网址上传（编程），CAD，平面设计 等等的知识，庆幸那是因为喜欢，将工具装在脑子里！
一下子都能用到，太爽了。（如果想学我可以教你们，不敢说我多厉害，对你来说是一种学习，对我来
说时一种复习巩固，发现新东西，共同学习 Emall：questeryu@qq.com）还有就是没事多看看书（乱
七八糟的书）这会不断地冲击你的认知和促进深度思考。

多发自内心去写写东西，这会促使人们深度思考，在这个信息如潮涌的时代，这些东西不断地收割
我们的注意力，使我们无法专注。遇到问题第一反应就是百度一下看看有没有答案（惯性思维），从来
不会想着自己试着去解决。整天刷视频，等等，我们看到的是别人创作出来的东西，我们为什么自己不
去创造呢？凭什么自己的注意力让别人来收割呢？

**奶头理论：**

前提：

社会动荡的主要因素之一是阶层之间的利益冲突。

**奶头乐理论的描述：**

由于生产力的不断上升，世界上的一大部分人口将不必也无法积极参与产品和服务的生产。
为了安慰这些“被遗弃”的人，避免阶级冲突，方法之一就是制造“奶头”、喂之以“奶头”——使令人
陶醉的消遣娱乐和充满感官刺激的产品（比如网络、电视和游戏）填满人们的生活、转移其注意
力和不满情绪，令其沉浸在“快乐”中不知不觉丧失思考能力、无心挑战现有的统治阶级。

**“奶头”的形式有两种：**

一种是发泄性娱乐，比如开放色情行业、鼓励暴力网络游戏、鼓动口水战；
一种是满足性游戏，比如拍摄大量的肥皂剧和偶像剧，大量报道明星丑闻，播放真人秀等大
众娱乐节目。


**奶头理论的来源：**

这一概念来自美国前总统国家安全事务助理布热津斯基。
美国旧金山曾于1995年举行过一个集合全球500名经济界、政治界精英的会议，与会者包
括萨切尔、老布什、美国有线电视新闻网（CNN）、惠普、Sun微系统的老板等等，该会议的
主旨在于为全球化的世界进行分析与规划。会议上，与会者一致认为全球化的高度、快速、激
烈的竞争将使全球80%人口"边缘化"，而这80%“边缘化”人口与20%搭上全球化快车的人口之
间的冲突将成为今后的主要问题。


在此基础上，Sun微系统的老板格基表示，届时将是一个“要么吃人、要么被吃”的世界。
布热津斯基也及时献计献策，创造了一个新词汇——tittytainment“奶头乐”，英文titty“奶头”
与entertainment “娱乐”的组合，意指要使彼80%的人安分守己，此20%的人高枕无忧，就得
采取温情、麻醉、低成本、半满足的办法卸除“边缘化人口”的不满。

**奶头理论：**https://wiki.mbalib.com/wiki/%E5%A5%B6%E5%A4%B4%E4%B9%90%E7%90%86%E8%AE%BA#.E5.A5.B6.E5.A4.B4.E4.B9.90.E7.90.86.E8.AE.BA.E5.9C.A8.E4.B8.AD.E5.9B.BD

让我们一起开始吧

##  设置代码格式

随着你编写的程序越来越长，有必要了解一些代码格式设置约定。请花时间让你的代码尽可
能易于阅读；让代码易于阅读有助于你掌握程序是做什么的，也可以帮助他人理解你编写的代码。
为确保所有人编写的代码的结构都大致一致，Python程序员都遵循一些格式设置约定。学会
编写整洁的Python后，就能明白他人编写的Python代码的整体结构——只要他们和你遵循相同的
指南。要成为专业程序员，应从现在开始就遵循这些指南，以养成良好的习惯。

### 格式设置指南

Python格式设置指南的编写者深知，代码被阅读的次数比编写的次数多。代码编写出来后，
调试时你需要阅读它；给程序添加新功能时，需要花很长的时间阅读代码；与其他程序员分享代
码时，这些程序员也将阅读它们。

### 缩进 、 行长and空行

很多Python程序员都建议每行不超过80字符。最初制定这样的指南时，在大多数计算机中，
终端窗口每行只能容纳79字符；当前，计算机屏幕每行可容纳的字符数多得多，为何还要使用79
字符的标准行长呢？这里有别的原因。专业程序员通常会在同一个屏幕上打开多个文件，使用标
准行长可以让他们在屏幕上并排打开两三个文件时能同时看到各个文件的完整行。PEP 8还建议
注释的行长都不超过72字符，因为有些工具为大型项目自动生成文档时，会在每行注释开头添加
格式化字符。
空行不会影响代码的运行，但会影响代码的可读性。Python解释器根据水平缩进情况来解读
代码，但不关心垂直间距。

# 变量和简单数据类型

## 整数类型

⚪十进制：1010，99，-234

⚪二进制：以0b or 0B开头：0b010，-0B101

⚪八进制：以0o or 0O开头：0o123，-0O345

⚪十六进制：以0x or 0X开头：0x9a，-0X89

## 浮点数类型

与数学中实数的概念一致

⚪带有小数点及小数的数字

⚪浮点数取值范围和小数精度都存在限制，但常规计算可以忽略

⚪取值范围数量级约$-10^{308}$至$10^{308}$,精度数量级$10^{-16}$

注意：浮点数间运算存在不确定尾数，不是bug(一般发生在$10^{-16}$左右。)

    Python将带小数点的数字都称为浮点数。大多数编程语言都使用了这个术语，它指出了这样
    一个事实：小数点可出现在数字的任何位置。每种编程语言都须细心设计，以妥善地处理浮点数，
    确保不管小数点出现在什么位置，数字的行为都是正常的。
    从很大程度上说，使用浮点数时都无需考虑其行为。你只需输入要使用的数字，Python通常
    都会按你期望的方式处理它们：'''


```python
a=0.2+0.1
b=0.1+0.3
print (a,b,sep="\n")
```

    0.30000000000000004
    0.4
    


```python
#但需要注意的是，结果包含的小数位数可能是不确定的：
a=0.2+0.1
b=0.3
print (a,b,a==b,sep="\n") #这里输出的结果为False 说明a!=b
```

    0.30000000000000004
    0.3
    False
    

在上面的程序运行结果发现a==b 输出结果是：False

**原因**

所有语言都存在这种问题，没有什么可担心的。Python会尽力找到一种方式，以尽可能精确
地表示结果，但鉴于计算机内部表示数字的方式，这在有些情况下很难。就现在而言，暂时忽略
多余的小数位数即可,在后面我会去讲解这个玩意的（需要时处理多余小数位的方式）

## 复数类型

与数学中的复数概念一致


复数实例
Z=1.24e-6+5.6e+68j

实部： Z.real获得实部

虚部： Z.imag获得虚部


```python
#如下
Z=1.24e-6+5.6e+68j
print(Z.real)     # Z.real获得实部
print(Z.imag)     # Z.imag获得虚部
```

    1.24e-06
    5.6e+68
    

这就是复数的两个属性

客观来讲复数类型在常规计算机编程中很少使用，但是它确实进行空间变换

尤其是跟复变函数相关的科学体系中最常用的一种类型

## 数据类型及操作

操作符是计算机完成运行的一种符号体系，python借鉴了许多数学中的操作符来完成数值运算

    ▶整数类型的无限范围及四种进制表示

    ▶浮点类型的近似无限范围、小尾数及科学计数法

    ▶+、—*、/、//、%、**、二元增强赋值操作符

    ▶abs(),divmod(),pow(),round(),max(),min()

    ▶int(),float(),complex()



 ### **⚪python的操作符号：**

|     操作符     |      描述      |
| -------------- | -------------- |
|x+y|加，x与y的和  |
|x-y|  减，x与y的差值|
|x*y|乘，x与y的积  |
|x/y|除，X与y的商 如：10/3=3.33333333|
|x//y|整除， 如：10/3=3|


### **⚪操作符及使用**

|     操作符     |      描述      |
| -------------- | -------------- |
|+x|x本身  |
|-y|y的负值|
|x%y|余数，模运算 10%3结果是1|
|x**y|幂运算。x的y次幂，$x^y$|
|            |当y是小数时，开方运算10**0.5的结果是${\sqrt 10}$|

除了基本的操作符外 python还提供了对二元操作符一种增强型的赋值操作符

它的基本功能是对2个数进行运算后，去更改其中一个数

### **⚪二元操作符一种增强型的赋值操作符**

|     操作符     |      描述      |
| -------------- | -------------- |
|x op y | 即 x=x op y， 其中，op 为二元操作符|
|       | x+=y  x_=y  x*=y  x/=y  x//=y  x%=y  x**=y|
|       |例えば：|
|       |>>>x=3.1415|
|       |>>>x ** =3  #与x=x**3等价|
|      |31.003533398375005|


```python
#举例如下：
x=3.1415
x=x**3
print(x)
```

    31.003533398375005
    

**数据类型的关系：**

类型间可以进行混合运算，生成结果为“最宽”类型

三种类型存在一种逐渐“扩展”or“变宽”的关系：    **整数 ==》浮点数 ==》复数**

### ⚪函数形式提供的数值运算功能

|函数及使用|描述|
|----------|----|
| abs（x）|绝对值，X的绝对值|
|         |abs（-10.01）结果为10.01|
|  divmod |商余，（x//y,x&y),同时输出商和余数|
|         |divmod（10，3）结果为（3，1）|
|pow(x,y[Z])|幂余，（x**y）%z，[..]表示Z参数可以省略|
|         | pow（3，pow(3,99),10000) 结果为4587|
|round（x,[d]）|四舍五入，d是保留小数位，默认值为0；|
|         |round（-10.234534，2）结果为-10.23|
|max（x1,x2,x3,...Xn)| 最大值，返回x1,x2,x3,...Xn中的最大值，n不限|
|         |max(1,2,3,5,7,43,5,665,4)结果为：665|
|min（x1,x2,x3,...Xn)| 最小值，返回x1,x2,x3,...Xn中的最小值，n不限|
|         |max(1,2,3,5,7,43,5,665,4)结果为：1|

**●举例“abs”and“divmod”如下：**


```python
x=-123.34
print("abs运行结果为：",abs(x)) #绝对值
print("divmod运行结果为：",divmod(10,3))  #商余函数
```

    abs运行结果为： 123.34
    divmod运行结果为： (3, 1)
    

**●举例“pow”如下：**


```python
x=pow(3,pow(3,99),10000)
print("运行结果为：",x)

#为什么会有余操作 “Z”这个参数出现呢？
#如果不加“Z”这个参数，那么pow(3,pow(3,99)）这个数据将会超出我们普通计算机的运行，
#无法在我们计算机中得到结果的（超出我们普通计算机的内存）
```

    运行结果为： 4587
    

**●round 函数 四舍五入，d是保留小数位，默认值为0，也就是取整**


```python
y=round(-10.234532,2)# 保留2位小数
print("运行结果为：",y)
```

    运行结果为： -10.23
    

⚪函数形式提供的数值运算功能

|函数及使用|描述|
|----------|----|
| int（x）|将X变成整数，舍弃小数部份|
|         |int（13.32)结果为：13  注意不进行四舍五入|
|         |也可以间字符串变成整数 如：int("123") 结果：123|
| float(x)|将X变成浮点数，增加小数部份|
|         |如：float("123") 结果：123.0 ;float(143) 结果：143.00|
| complex(x)|将X变成复数，增加虚数部份|
|         |complex(4)结果4+0j|

**●举例“int”如下：**


```python
# int 函数
print("小数转化结果：",int(13.32))
print("符串转化结果：",int("123"))
```

    小数转化结果： 13
    符串转化结果： 123
    

**●举例“float”如下：**


```python
# float 函数
print("小数转化结果：",float(13))
print("符串转化结果：",float("123"))
```

    小数转化结果： 13.0
    符串转化结果： 123.0
    

**●举例“complex”如下：**


```python
print("结果：",complex(32))
```

    结果： (32+0j)
    

### 关于上面我们来做一个练习

**关于复利思维**

查理芒格说：每天起床的时候，争取变得比你从前更聪明一点。

认真地、出色地完成你的任务。慢慢地，你会有所进步，但这种进步不一定很快。

但你这样能够为快速进步打好基础……每天慢慢向前挪一点。到最后——如果你足够长寿的话——大多数人得到了他们应得的东西。


**关于如何获得幸福和成功**

如果你在生活中惟一的成功就是通过买股票发财，那么这是一种失败的生活。生活不仅仅是精明地积累财富。

生活和生意上的大多数成功来自于你知道应该避免哪些事情：过早死亡、糟糕的婚姻等等。

避免染上艾滋病、在路口和火车抢道以及吸毒。培养良好的心理习惯。

避免邪恶之人，尤其是那些性感诱人的异性。

如果因为你的特立独行而在周围人中不受欢迎……那你就随他们去吧。

**这本书《穷查理宝典》如果你决定读一遍的话就不要读了**



看过这样一段话：“人生在世，虽然有国家、阶级、出身、财富这些先天的不同

但是幸运的是：每个人每天有24小时。具体怎么使用着24小时，就决定了你是生活在哪个世界的人

**●练习一**

**Q1**：一年有365天，每天进步1‰ 累计会进步多少？


```python
print("累计进步：",pow(1.001,365),"\n一年你的能力将提高{:.2f}倍".format(pow(1.001,365)))
```

    累计进步： 1.4402513134295205 
    一年你的能力将提高1.44倍
    

**Q2：**一年有365天，每天**退步**1‰ 累计会是多少呢？


```python
print("累计退步：",pow(0.999,365),"\n一年你的能力将退步{:.2f}倍".format(pow(0.999,365)))
```

    累计退步： 0.6940698870404745 
    一年你的能力将退步0.69倍
    


```python
# 我们将上面的①and② 编写为一个程序

dayup  =pow(1.001,365)
daydown=pow(0.999,365)
print("累计进步:{:.2f}\n累计退步:{:.2f}".format(dayup,daydown))
```

    累计进步:1.44
    累计退步:0.69
    

想想如果你每天进步千分之一，一年会在原来的基础上面成长1.4倍

如果每天退步千分之一，一年将会变为0.69 不容小觑[bù róng xiǎo qù]啊

**●练习二**

**Q1：**一年进步5‰ or 1%，累计进步多少呢

**Q2：**每天退步5‰ or 1%，累计剩下多少呢？

这里涉及变量5‰ and 1% 我们可以使用input函数和eval函数


        eval函数能够将一个字符串两边的引号去掉，变成一个Python能够运行语句
       
        在说明一点：str(x)函数将任意类型的变量增加引号变成字符串




```python
#如下：
a=input("please you input number：")
if a[-1] in ["‰"]:
    y=eval(a[0:1])/1000
    
elif a[-1] in ["%"]:
    y=eval(a[0:1])/100

dayup  =pow(1+y,365)
daydown=pow(1-y,365)
print("累计进步:{:.2f}\n累计退步:{:.2f}".format(dayup,daydown))
```

    please you input number：5‰
    累计进步:6.17
    累计退步:0.16
    

**①可以看到如果每天浮动5‰；**

    一年累计进步 累计进步:6.17； 

    累计退步:0.16

**② 如果每天浮动1%；**

    累计进步:37.78

    累计退步:0.02

**Q3：**

    一年365天 工作日为星期一到星期五 休息日为星期六星期天
    （对我来说从来就不存在休假！因为每天要为自己工作）
    假设：
        工作日进步1%，休息日退步1%
重要的是：**数学思维**>>>>>>>>**计算机思维**

如何让计算机模拟工作日增加，休息日减少


```python
#如下：
dayup=1.0
dayfactor=0.01
for i in range(365) : #判断工作日和休息日
    if i%7 in [6,0]:
        dayup=dayup*(1-dayfactor)
    else:
        dayup=dayup*(1+dayfactor)
print("工作日的力量：{:.2f}".format(dayup))
```

    工作日的力量：4.63
    

如果一个人（A同学）每天努力1%，一年将会变成37.78


```python
dayup  =pow(1.01,365)
dayup
```




    37.78343433288728



对于另外一个人来说 工作日提升，休息日退步，那么他每天要每天努力多少才能赶的上A同学呢？


```python
#如下 先造个轮子
def dayUP(df):
    dayup=1.0

    for i in range(365) : #判断工作日和休息日
        if i%7 in [6,0]:
            dayup=dayup*(1-0.01)
        else:
            dayup=dayup*(1+df)
    return dayup
dayfactor=0.01
while dayUP(dayfactor)< 37.78:
    dayfactor+=0.001
print("工作日努力参数是：{:.3f}才能够超过A同学".format(dayfactor))
```

    工作日努力参数是：0.019才能够超过A同学
    

努力固然很重要，但是选择是前提，

可以去玩一下规划性求解，运筹学知识，对于自己的一些决策还是很有帮助的！大概率避免自己失败

可以参考 《赢得输家的游戏》，作为非专业人士，就让对方主动犯错误，才能够和他们去竞争

以下内容源于网络：（侵删）


    1975年，查尔斯·艾里斯在《金融分析家月刊》上发表了一篇重要的文章，专门讨论“如何把体育竞技中的赢的策略转嫁到投资中”，题目就叫《输家的游戏》，第一次把投资称为"输家的游戏"。

    艾里斯发现，有意思的是，原来是少数专业选手参加的赢家的游戏，如果吸引了太多人参加，所有人都想赢，就会变成输家的游戏。

    原来股市是赢家的游戏，市场中只有少数专业机构，大部分是业余散户，可以说是散户主导的市场，这些专业机构实力比散户强得多，可以轻松战胜散户主导的市场，业绩远远超过平均水平。

    但后来证券市场发展越来越快，专业机构越来越多，管理的资产规模也越来越大，像美国股市机构占比94％左右，早在1950年，这个数据是属于个人投资者的，如今专业机构已经在美国股市占据了压倒性优势，成了机构主导的市场。

    机构再也不是和资金少、实力弱的散户竞争，而是和其他机构进行竞争，这些机构资金实力不比自己弱、研究能力不比自己差，大家都是专业选手。

    结果股市成了专业机构之间输家的游戏，你无法比对手更强，只能让自己比对手失误更少，这样才能以很小的优势赢得比赛。

自主管理投资组合的观念让很多投资者感到畏缩。事实上，正确的解决方法是要找到一种基本的、简单的方法来应对在个人投资周期内的市场下跌。正如查尔斯发现，我们需要“注意我们不能委托给他人的部分——为自己考虑，为自己行动”，毕竟，“我们就是这样做出其他决定的，如和谁结婚，在哪里生活，是否要学会一种乐器，去哪里运动，打什么领带，点什么菜……”要把管理投资组合列入自己的职责清单。

⚪**极少有理财经理会把客户的利益放在第一位，督促投资者对自己的投资组合负责。**在利益至上的华尔街，客户的利益被置于理财经理的自身利益之后。让经纪商（佣金）、基金经理（基金规模）和金融顾问（高额费用）获益的投资组合，恰恰会让投资者受害。如果利益和责任相冲突，理财经理只会损人利己。

理解你的投资

⚪投资界 存在两种投资者——能做出高质量积极管理决策的一小撮精英分子和既无资源又没接受过战胜市场所需训练的大部分人。要想成为精英中的一员，需要全身心投入，理解和利用市场机会。能做到这点的人凤毛麟角。不幸的是，很多人都想象自己拥有积极管理（击败市场）的技能，从而追求代价高昂的策略，最终却走向失败。

⚪绝大多数的投资者都应该加入“消极管理俱乐部”。在这个俱乐部里，成员们并不会在今天异常高效的市场中寻找边边角角的机会，而是明智地接受市场的一切。关于投资指数基金的跟踪市场策略，查尔斯举了一个十分有力的例子，说明了指数基金简单、透明、低成本、税收优惠、高收益等特点。



#  字符串类型及操作

    ▶字符串类型的表示

    ▶字符串操作符

    ▶字符串处理函数

    ▶字符串处理方法

    ▶字符串类型格式化

### 变量

什么是变量：



```python
message = "Hello Python world!"
print(message) #其中message就是变量
```

    Hello Python world!
    

**其中massage就是变量**

### **字符串**

    由0个或多个字符组成的有序字符序列
        —字符串由一对单引号or一对双引号表示
        如："hello word" or 'Hello word'
        字符串是字符的有序序列，可以对其中的字符进行索引
            （字符的索引是从0开始编号
    

#### 使用方法修改字符串的大小写


```python
name="questeryu"
print(name.title())
#title 是将字符中的首字母进行大写
```

    Questeryu
    

在这个示例中，小写的字符串"questeryu"存储到了变量name中。在print()语句中，方法

title()出现在这个变量的后面。方法是Python可对数据执行的操作。在name.title()中，name后

面的句点（.）让Python对变量name执行方法title()指定的操作。每个方法后面都跟着一对括号，

这是因为方法通常需要额外的信息来完成其工作。这种信息是在括号内提供的。函数title()不

需要额外的信息，因此它后面的括号是空的。

title()以首字母大写的方式显示每个单词，即将每个单词的首字母都改为大写。这很有用，

因为你经常需要将名字视为信息。例如，你可能希望程序将值Ada、ADA和ada视为同一个名字，

并将它们都显示为Ada。



```python
#还有如下操作
name= "qUrsteryu"
print(name.upper()) #将字母全部大写
print(name.lower()) #将字母全部小写
print(name.title()) #将字母首字母大写
```

    QURSTERYU
    qursteryu
    Qursteryu
    

### **字符串类型合并（拼接）**

如下：


```python
first_name="Quester"
last_name="yu"
full_name=first_name+" "+last_name
print(full_name)
```

    Quester yu
    


```python
#用"+"表示字符串与字符串的连接
print("Hello "+full_name+"!")
```

    Hello Quester yu!
    


```python
#还有可以用乘法来运算
x="Hello "
print(x*3)  #可以看到输出3个3
```

    Hello Hello Hello 
    

#### 使用函数str()避免类型错误


```python
age = 23   #这是一个整数类型（int）
message = "Happy " + age + "rd Birthday!"
#这段代码会运行错误! TypeError: can only concatenate str (not "int") to str
# 这里的原因就是类型错误 因为“age”是一个int型
```


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-70-ccbe31339fc5> in <module>
          1 age = 23   #这是一个整数类型（int）
    ----> 2 message = "Happy " + age + "rd Birthday!"
          3 #这段代码会运行错误! TypeError: can only concatenate str (not "int") to str
          4 # 这里的原因就是类型错误 因为“age”是一个int型
    

    TypeError: can only concatenate str (not "int") to str



```python
#运行错误，我们查看发现是类型错误，因此我们查看类型
type(age)
```




    int




```python
#我们可将int型转化为字符串型
age=str(age)
age
type(age)
```




    str




```python
#我们通过上面的程序将类型统一，因此就可以运行第一个程序了
age = 23   #这是一个整数类型（int）

# 类型转化
age=str(age)  #将整形转化为字符串型
message = "Happy " + age + "rd Birthday!"

message
```




    'Happy 23rd Birthday!'



### 删除空白字符串中的空格（rstrip(尾部),lstrip(首部),strip(首尾))


```python
#可以剔除字符串开头的空白，或同时剔除字符串两端的空白。为此，可分别使用方法lstrip()：和strip()：
a= "   python  "
print(len(a))  #a字符串的长度 长度为“12”；

print(a.rstrip())  #删除尾部空格 output："   python"

print(len(a.rstrip())) #删除尾部空格后，字符串的长度 长度为：“9”；

print(a.lstrip())#删除字符串开头的空格  output："python   "
print(len(a.lstrip())) #删除字符串开头的空格 字符串的长度 长度为：“8”
print(a.strip())# #删除字符串首尾空格
print(len(a.strip()))#输出字符长长度
```

    11
       python
    9
    python  
    8
    python
    6
    


```python
a="    Questeryu   "

#确认字符串长度
print(len(a))

#删除字符串首部的空格函数：str.lstrip()
print(a.lstrip())
print(len(a.lstrip()))

#删除字符串尾部的空格函数：str.rstrip()
print(a.rstrip())

#删除首尾空格，函数：str.strip()
print(a.strip())
```

    16
    Questeryu   
    12
        Questeryu
    Questeryu
    

### 四种字符串表达：

 ▶第一种 
 
"Hello word"（双引号）


▶第二种

'Hello word'（单引号）

▶第三种  这种表示方法是用于大批量or 存在换行的情况下（三单引号）

    '''

        Hello word
    
    '''

▶第四种  这种表示方法是用于大批量or 存在换行的情况下（三双引号）

    """

        Hello word
    
    """

为什么会有提供四种这样的注释呢？

    Q：考虑文本重锤昂单引号or双引号怎么办呢？
    
     A:如果我们使用双引号表示字符串，那么如果字符串中出现双引号，那么程序就会出现错误
     
     A：因此Python提供了一种简单的方法，如果在字符串中出现双引号，那么最外层的引号就要使用双引号。
     
     A：如果字符串中既有单引号也有双引号，那么可以使用三个单引号or三个双引号

字符串的序号

正向递增，反向递减

![title](C:/Users/QUESTERYU/Desktop/字符串序号.JPG)  

### **索引和切片**

符串的两个重要操作： **索引**和**切片**

使用[]来获取字符串中一个or多个字符

    ▶索引返回字符串中单个字符  <字符串>[M]


```python
# 索引举例
a="124.4534dfsdfsf"  # 如果输入时，不知道数据是什么类型，那么可以用 type()查看函数类型 

#即：
print("a的数据类型是：",type(a))

#如果我们想知道最后一个字符串是多少时，即：a[-1]
print ("最后一个字符串是：",a[-1]) #输出结果即f

#如果要找到第三位的字符 即：a[2] 因为计算机是从0开始计数的
print ("第三位的字符是：",a[2])
```

    a的数据类型是： <class 'str'>
    最后一个字符串是： f
    第三位的字符是： 4
    


```python
#切片是通过<字符串>[M:N:K]组成的
a="124.4534dfsdfsf"
print(a[1:3])

# 高级用法 
# <字符串>[M:N],M缺失表示至开头，N缺失表示至末尾
"⭕1a2derew突然rgg"[:4]
```

    24
    




    '⭕1a2'




```python
#带参数K 使用[M:N:K]根据步长对字符串切片
"0123456789"[::-1]  #这个算法也可以进行逆序操作

```




    '9876543210'




```python
a="0123456789"[::2]  #输出为以步长为2的字符串,这里的a是字符串，是不能够参与运算的
type(a)  #可以看到结果是字符串 str 
print(a)
```

    02468
    


```python
#如果想要字符串中的数字时，一定要将字符串转化为 数字  使用eval函数
a="123456789"[::2]
c=eval("123456789"[::2]) #输出为以步长为2的字符串,这里的a是字符串，是不能够参与运算的
print(c)
```

    13579
    


```python
colors=["yellow","blue","red","black","green","purple"]
#我们用切片输出前三个元素
print(colors[0:3])
#如果你要提取列表的第2~4个元素，可将起始索引指定为1，并将终止索引指定为4：
print(colors[1:4])
#如果你没有指定第一个索引，Python将自动从列表开头开始：
print(colors[:4])
#要让切片终止于列表末尾，也可使用类似的语法
print(colors[2:])
#还有一个索引（负数索引）如果一个list很大你不知道后面的数字，\
#这时你想要最后三个值，这时就使用负数切片
print(colors[-3:])
```

    ['yellow', 'blue', 'red']
    ['blue', 'red', 'black']
    ['yellow', 'blue', 'red', 'black']
    ['red', 'black', 'green', 'purple']
    ['black', 'green', 'purple']
    

处理数据时，可使用切片来进行批量处理；编写Web应用程序时，
可使用切片来分页显示信息，并在每页显示数量合适的信息。

### **字符串的特殊符号 转义符**

**转义符\**

        ▶转义符表达特定字符的本意
            "这里有个双引号(\")" 结果为  这里有个双引号(")
            
        ▶转义符也可以形成一些组合，表达一些不可打印的含义
          "\b"回退，"\n"换行（光标移动到下首行）  "\r"回车（Enter）（光标移动到首行开头）


```python
print("这里有个双引号(\")")
```

    这里有个双引号(")
    

#### **⚪字符串的操作**
        
        ●字符串的处理函数

|函数及使用|描述|
|----------|----|
| len（x）|长度 返回字符串（x）的长度|
| str(x)|任意类型x对应的字符串形式    |
| hex(x)or oct(x)|整数x的十六进制or八进制小写形式的字符串|
|chr(u)|u为Unicode编码，返回其对应的字符|
|ord(x)|x为字符，返回其对应的Unicode编码|


```python
![title](C:/Users/QUESTERYU/Desktop/编码.JPG)
```

    '[title]' 不是内部或外部命令，也不是可运行的程序
    或批处理文件。
    


```python
# 如： len(x)返回字符串（x）的长度

#注意： 在Python中无论是数字，标点符号英文字母or 汉字。
#它们都是一个字符，长度相同，这里没有找到多行注释 
#如果你知道请告诉我谢谢！ Q:如何在Jupyter Notebook代码块中进行多行注释
# 联系我，谢谢！Questeryu@qq.com
len("1355nihao") 
```




    9




```python
#str(x)   任意类型x对应的字符串形式 
a=str(123)
b=str([1,2,3])
print(a)
print(b)
```

    123
    [1, 2, 3]
    

⚪BIN_OCT_HEX_DEC_在英语中的意思：

    1、BIN：binary，二进制的;

    2、OCT：octal，八进制的;

    3、HEX：hexadecimal，十六进制的;

    4、DEC：decimal，十进制的。


```python
i=325
print("二进制：{}\n八进制：{} \n十六进制：{}".format(bin(i),oct(i),hex(i)))
```

    二进制：0b101000101
    八进制：0o505 
    十六进制：0x145
    


```python
a=[]
for i in range(6789,6876):
    a.append(chr(i)) #append函数在字符串操作会详细介绍
print("{}".format(a))
```

    ['᪅', '᪆', '᪇', '᪈', '᪉', '\u1a8a', '\u1a8b', '\u1a8c', '\u1a8d', '\u1a8e', '\u1a8f', '᪐', '᪑', '᪒', '᪓', '᪔', '᪕', '᪖', '᪗', '᪘', '᪙', '\u1a9a', '\u1a9b', '\u1a9c', '\u1a9d', '\u1a9e', '\u1a9f', '᪠', '᪡', '᪢', '᪣', '᪤', '᪥', '᪦', 'ᪧ', '᪨', '᪩', '᪪', '᪫', '᪬', '᪭', '\u1aae', '\u1aaf', '᪰', '᪱', '᪲', '᪳', '᪴', '᪵', '᪶', '᪷', '᪸', '᪹', '᪺', '᪻', '᪼', '᪽', '᪾', '\u1abf', '\u1ac0', '\u1ac1', '\u1ac2', '\u1ac3', '\u1ac4', '\u1ac5', '\u1ac6', '\u1ac7', '\u1ac8', '\u1ac9', '\u1aca', '\u1acb', '\u1acc', '\u1acd', '\u1ace', '\u1acf', '\u1ad0', '\u1ad1', '\u1ad2', '\u1ad3', '\u1ad4', '\u1ad5', '\u1ad6', '\u1ad7', '\u1ad8', '\u1ad9', '\u1ada', '\u1adb']
    


```python
print("将字符⭐转化为Unicode编码:{}\n\n将Unicode编码‘11088’转化为字符:{}".format(ord("⭐"),chr(11088)))
#这个有点长，一般最好是代码长度要小，便于阅读
```

    将字符⭐转化为Unicode编码:11088
    
    将Unicode编码‘11088’转化为字符:⭐
    

Unicode编码是Python字符串的编码形式。

在Python3中所有的代码，字符串，全部是采用Unicode编码来实现的

在计算机短暂的发展历史上，有很多编码存在

由于计算机时欧洲人和美国人（美国人是欧洲人吗？）发明的

因此在最开始的计算机中只有英文字符，然而英文字符的空间范围很有限

国际上广泛使用ASCII码来表示所有的英文字符

随着计算机广泛的应用到世界各地 比如中国 我们有大量的中文汉字

如何对中文汉字编码，如何让计算机处理中文汉字

This is a very important issue（这是一个很重要的问题）

所以国际上的一些学者及企业界的工程师（Engineer）共同研制了一种同意的字符编码

基本思想：

    希望用一套编码能够把世界上所有的字符纳进来
    
    只要有一个字符，它（她）就会有一个对应的编码和字符表示
    
    这样我们再去编写程序，再去支撑应用，就会变得非常简单
    
 **这就是Unicode的由来**


```python
#for example：
'1+1=2 '+chr(10004)
```




    '1+1=2 ✔'




```python
# 关于十二星座
# 第一个星座(白羊座）对应的是Unicode编码是： 9800 分别输出十二星座

a=[]
for i in range(9800,9812):
    a.append(chr(i))
print("十二星座分别是：",a)
print(a,end="")
```

    十二星座分别是： ['♈', '♉', '♊', '♋', '♌', '♍', '♎', '♏', '♐', '♑', '♒', '♓']
    ['♈', '♉', '♊', '♋', '♌', '♍', '♎', '♏', '♐', '♑', '♒', '♓']

#### **字符串的处理方法**

**"方法"在编程中是一个专有名词**

    ①"方法"特指<a>.<b>()风格中的函数<b>()
    
    ②方法本身也是函数，但与<a>有关，<a>.<b>()风格使用
    
    ③字符串及变量也是<a>对象，存在一些方法
    
    ④<a>.<b>()风格恰恰也是一种面像对象编程  其中<a>是对象，<b>是面向对象提供的功能 即：方法

#### **⚪在Python中常用的8个字符串处理方法**

    这8个字符串处理方法在以后的数据分析、爬虫将会大量的应用

|方法及使用|描述|
|----------|----|
|str.lower() and str.upper()|返回字符串的副本，全部字符小写/大写|
|str.split(sep=None)|返回一个列表，由str根据sep被分割的部份组成|
|str.count(u)|返回字串在str中出现的次数|
|str.replace(old,new)|返回str副本，所有old字串被替换为new|
|str.center(width[,fillchar])|字符串str根据宽度width居中，fillchar可选|
|str.strip(chars)|从str中去掉在其左侧和右侧chars中列出的字符|
|str.join(iter)|在iter变量除最后一个元素外，每个元素后面怎加一个str|

    

#### **① str.lower() and str.upper() 应用**


```python
#for example：
#str.lower() and str.upper()

a="QUESTERyu"
a.lower()    #将字符串中的字母全部小写
a.upper()    #将字符串中的字母全部大写

print(a.lower(),'\n',a.upper())
```

    questeryu 
     QUESTERYU
    

**lower
        英 [ˈləʊə(r) , ˈlaʊə(r)]
                美 [ˈloʊər , ˈlaʊər]**


adj.
(尤指位于同类物品或成对物品中另一个的)下面的，下方的;在底部的;近底部的;朝海岸的;低洼的;向南的

v.
把…放低;使…降下;减少;缩小;降低

v.
变昏暗;变恶劣;变阴沉

adv.
低;向下;不高;在靠近…底部的位置;向…底部;低于通常(或期望)的水平

low的比较级

**upper 	英 [ˈʌpə(r)]
	美 [ˈʌpər]**
    
adj.
上边的，上面的，上层的(尤指同类或一对中的一个); 上部的; 靠上部的; 内陆的; 高地的; 向北部的;

n.
 鞋帮; 靴面; 兴奋剂

    

#### **② str.split(sep=None) 	返回一个列表，由str根据sep被分割的部份组成**


```python
#for example：
#str.split(sep=None)

"QU,E,S,T,E,R,Y,U".split(",") #通过字符串中的","分割，将它们组成一个列表（list）反馈给用户

#type("Q,U,E,S,T,E,R,Y,U".split(","))  #查看类型
```




    ['QU', 'E', 'S', 'T', 'E', 'R', 'Y', 'U']



**split 	英 [splɪt]
	美 [splɪt]**
    
v. 	分裂，使分裂(成不同的派别); 分开，使分开(成为几个部分); 分担; 分摊; 分享;

n. 	分歧; 分裂; 分离; 划分; 分别; 份额; 裂缝; 裂口;




#### **③ str.count(u)返回字串在str中出现的次数**


```python
#for example：
#str.count(a)|返回字串在str中出现的次数

"I like MacBook por".count('o')  #在这个字符串中出现了3次
```




    3



**count 	英 [kaʊnt]
	美 [kaʊnt]**
    
v. 	(按顺序) 数数; 计算(或清点)总数; 把…算入; 包括;

n. 	数出总数; 总数; (按顺序的) 数数，点数; (某物质在某物或面积中) 量的计数; 伯爵（欧洲一些国家相当于英国earl的贵族封号; 

   
      

**④ str.replace(old,new) 返回str副本，所有old字串被替换为new**



```python
#for example:
#str.replace(old,new) 返回str副本

"Hello word".replace("word","Honey")
```




    'Hello Honey'



**replace 	英 [rɪˈpleɪs]美 [rɪˈpleɪs]**

v. 	代替; 取代; (用…) 替换; (以…) 接替; 更换; 更新;

#### **⑤ str.center(width[,fillchar]) 字符串str根据宽度width居中，fillchar可选**


```python
# for example:
"Hello word".center(20,"-")  #这个单词就不翻译了！就是中心的意思。
```




    '-----Hello word-----'



#### **⑤ str.strip(chars)从str中去掉在其左侧和右侧chars中列出的字符** 


```python
# for example:
"hello word".split("o")
```




    ['hell', ' w', 'rd']




```python
",".join("1234fdfds") #用来对字符串分割
```




    '1,2,3,4,f,d,f,d,s'



**⚪字符串的格式化**

字符串格式化使用.format()方法 用法如下：

<模板字符串>.format(<逗号分隔的参数>)

占位符 用{}表示，它只在字符串中有用

![title](C:/Users/QUESTERYU/Desktop/槽.JPG)

format（）方法的格式控制

|   冒号   |  <填充>  |  <对齐>  |  <宽度>  |   <,>   |  <.精度>  |  <类型>  |
|----------|----------|----------|----------|----------|----------|----------|
|引导符号|用于填充的单个字符|<左对齐；>右对齐；^居中对齐|槽设定的输出宽度|数字的千位分割符|浮点数小数精度；or字符串最大输出长度|整数类型b,c,d,o,x,X 浮点数类型e,E,f,%|

前面三个可以分为一组，后面三个为另外一组(和数字有关）


```python
#for exmaple：前三个操作
print("{:=^20}".format("Hello word"))
print("{:*>20}".format("APPLE"))
```

    =====Hello word=====
    ***************APPLE
    


```python
#for exmaple：后三个操作（和数字有关
"{:,.3f}".format(123487654.65432) #这里的“,”是数字千分为分割符，一般用于财务计算等
```




    '123,487,654.654'



**⚪字符串总结**
    
    ①正向递增序号，反向递增序号 <字符串>[M:N:K]
        +,*,len(x),str(),hex(),oct(),ord(),chr()ord(),chr()
        .lower(),.upper(),.split(),.count(),.replace()
        .center(),srip(),.jion(),.format()格式化

## 小插曲（醒脑）——Python之禅

讲解写代码的一些规范
Python程序员笃信代码可以编写得漂亮而优雅。

编程是要解决问题的，设计良好、高效而漂亮的解决方案都会让程序员心生敬意。

随着你对Python的认识越来越深入，并使用它来编写越来越多的代码，

有一天也许会有人站在你后面惊呼：“哇，代码编写得真是漂亮！”


```python
import this
```

    The Zen of Python, by Tim Peters
    
    Beautiful is better than ugly.
    Explicit is better than implicit.
    Simple is better than complex.
    Complex is better than complicated.
    Flat is better than nested.
    Sparse is better than dense.
    Readability counts.
    Special cases aren't special enough to break the rules.
    Although practicality beats purity.
    Errors should never pass silently.
    Unless explicitly silenced.
    In the face of ambiguity, refuse the temptation to guess.
    There should be one-- and preferably only one --obvious way to do it.
    Although that way may not be obvious at first unless you're Dutch.
    Now is better than never.
    Although never is often better than *right* now.
    If the implementation is hard to explain, it's a bad idea.
    If the implementation is easy to explain, it may be a good idea.
    Namespaces are one honking great idea -- let's do more of those!
    

# time 库的使用

##  time库的基本介绍

② 时间获取

③ 时间格式

④ 程序计时应用

=>time库的基本介绍
    
    time库是Python中处理时间的标准库
        
        计算机时间的表达
        提供系统时间并格式化输出功能
        提供系统精确计时功能，用于程序性能分析
                如下：import time
                        time.<b>()
                        
=>time库包括三类函数

    时间获取：time（） ctime（）g'mtime（）
    时间格式化：strftime() strptime()
    程序计时：sleep(),perf_counter()

### time库的使用

|函数|描述|
|-----|-----|
|time()|获取当前时间戳，即计算机内部的时间值=>浮点数|
|ctime()|获取当前时间并以易读的方式表示，返回字符串|
|gmtime()|获取当前时间，表示为计算机可处理的时间格式|

① time函数和ctime函数举例


```python
#for example 
import time
print(time.time()) #这是一个很长的浮点数，我们很难看到它表达的含义
print(time.ctime()) #获取当前时间，以易读的方式表示出来
print(time.gmtime())
```

    1597415853.7314496
    Fri Aug 14 22:37:33 2020
    time.struct_time(tm_year=2020, tm_mon=8, tm_mday=14, tm_hour=14, tm_min=37, tm_sec=33, tm_wday=4, tm_yday=227, tm_isdst=0)
    

② 时间格式化

    格式化：类似字符串格式化，需要有展示模板
    展示模板由特定的格式化控制符组成
    strftime()方法

    关于strftime函数

|函数|描述|
|---|-----|
|strftime(tpl,ts)|tpl是格式化模板字符串，用来定义输出效果|
|               |ts是计算机内部时间类型变量|
|srtptime(str,tpl)| str是字符形式的时间值；tpl是格式化模板字符串，用来定义输入效果|


```python
t=time.gmtime()
a=time.strftime("%Y-%m-%d %H:%M:%S",t)
a
```




    '2020-08-14 14:37:42'




```python

time.strptime(a,"%Y-%m-%d %H:%M:%S") 
```




    time.struct_time(tm_year=2020, tm_mon=8, tm_mday=14, tm_hour=14, tm_min=37, tm_sec=42, tm_wday=4, tm_yday=227, tm_isdst=-1)



**可以看出 strptime函数和strftime是存在互补关系**

⚪ 程序计时 time库的使用

    程序计时是指测量起止动作经过的时间
    简单来讲：程序从开始运行到结束所花费的时间，就叫程序计时
    程序计时在计算机中有广泛的应用，它指的是测量起止动作所经历时间的过程
    
    程序计时主要分为2个部份：测量时间 和 产生时间 两个部份
    测量时间：能够记录时间的流逝 在time函数中提供了一个精准的时间测定
        测量时间：perf_counter()
                函数说明：
                    Docstring:
                        perf_counter() -> float                   #浮点数类型
                        Performance counter for benchmarking.     #用于基准测试的性能计数器
                        Type:  builtin_function_or_method         #类型 ：内置函数类型or方法
                        
     为什么说精准呢？因为它可以获取计算机中CPU（中央处理器）以其频率运行的时钟，
     这个时间往往是以纳秒来计算，因此这样的时间会非常的精准（是否可以用程序来确定计算机CPU处理能力？）
        产生时间：sleep（）让程序休眠or产生一定的时间

|函数|描述|
|----|----|
|perf_counter()|返回一个CPU级别的精确时间计数值，单位为秒|
|              |由于这个计数的起点不确定，连续调用取差值才有意义|
|sleep(s)|s拟休眠的时间，单位是秒，可以是浮点数|


```python
start=time.perf_counter()
end  =time.perf_counter()
end-start
```




    4.389999958220869e-05




```python
# 关于time.perf_counter函数可以用来测试CPU的性能  精度可以达到纳秒级别
import time
start=time.perf_counter()

# 加入一段循环 看看CPU的测试CPU的反应速度，
#不同电脑不同CPU反应速度不一样，就可以知道电脑的CPU好不好了

for i in range(2,345):   
        i+=1
end=time.perf_counter()
print(end-start)


start1=time.perf_counter()
end1=time.perf_counter()
print(end1-start1)

print((end-start)>(end1-start1))
print("差值：",(end-start)-(end1-start1))
```

    0.00013620000027003698
    3.730000025825575e-05
    True
    差值： 9.890000001178123e-05
    


```python
def wait():
    time.sleep(3)   # 自定义函数 等待三秒执行

    
start=time.perf_counter()  

wait() #调用自定义函数

end=time.perf_counter()

print(end-start)
```

    2.9911160000001473
    

## time库总结

#### 时间获取：time() ctime() gmtime()
#### 时间格式化：strftime() strptime()
#### 程序计时：perf_counter() sleep()


```python
#文本进度条   练习字符串和
import time
scale=10
print("--------程序执行开始--------")   #这段代码也可以这样写：print("程序执行开始".center(20,"="))
for i in range(scale+1):
    a="*"*i
    b="."*(scale - i)
    c=(i/scale)*100
    print("{:^3.0f}%[{}->{}]".format(c,a,b))
    time.sleep(0.1)
print("--------程序执行结束--------")
```

    --------程序执行开始--------
     0 %[->..........]
    10 %[*->.........]
    20 %[**->........]
    30 %[***->.......]
    40 %[****->......]
    50 %[*****->.....]
    60 %[******->....]
    70 %[*******->...]
    80 %[********->..]
    90 %[*********->.]
    100%[**********->]
    --------程序执行结束--------
    


```python
#重新在写一遍 （一定要读懂代码来进行默写，这样会提高自己的编程水平）
import time
x=10
print("程序执行开始".center(20,"="))   #使用我们上面学习过的 str.center(width,[宽度])
for i in range(x+1):
    a="*"*i
    b="."*(x-i)
    c=i/10*100
    time.sleep(0.5)
    print("\r{:.2f}%[{}->{}]".format(c,a,b),end="")  #print函数中end的默认值是换行，为了实现刷新的的效果，因此将print函数中end改为end=""
print("\n","程序执行结束".center(20,"="))   
```

    =======程序执行开始=======
    100.00%[**********->]
     =======程序执行结束=======
    

**print函数说明**

Docstring:
print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)    #为了实现刷新效果（不换行）将end参数改为空值即可

Prints the values to a stream, or to sys.stdout by default.

Optional keyword arguments:

file:  a file-like object (stream); defaults to the current sys.stdout.

sep:   string inserted between values, default a space.

end:   string appended after the last value, default a newline.   #end参数默认为换行 

flush: whether to forcibly flush the stream.

Type:      builtin_function_or_method

## 总结

数据类型：整数，浮点数，复数

数据类型运算操作符，运算函数

字符串类型，表示，索引 切片

字符串操作符、处理函数、处理方法。.format（）格式化

time库 time() strftime() strptime() sleep()


# 程序的控制结构

程序的分支结构

程序的循环结构

## 程序的分支结构

单分支结构

二分支结构

多分支结构

多条件判断及组合

程序异常处理

### 单分支结构

**根据判断条件结果选择不同向前路径的运行方式**
    
    if <条件>：
        <语句块>
        
相信大家对猜数字游戏一定不会陌生吧 来我们一起写一个；主要采用了一个二分法

### 二分支结构

**根据条件的判断不同，而选择不同执行路径的这么一种结构**
    
    if<条件>：
        <语句块1>
    else：
        <语句块2>
        
**二分支结构的紧凑形式**

    <表达式1>if<条件>else<表达式2>
    
### 多分支结构

**典型表达方式**
    
    if<条件>：
        <语句块1>
    elif：
        <语句块2>
        ......
    else:
        <语句块3>
        



```python
# 二分之结构举例（紧凑型举例）

#优点：用非常简单的结构（一行代码）来表示二分支结构
#注意：在紧凑形式的二分支结构中 if else 对应的不是语句而是表达式  不支持赋值

guess=eval(input())
print("猜{}了".format("对"if guess==99 else "错"))
```

    2
    猜错了
    


```python
#多分支结构举例
# 我们上学会将成绩分为A（>=90,<100），B(>=80)，C(>=70)，D(>=60)，E(<60)等级

#如下：
a= eval(input("请输入成绩："))#请输入成绩

if 90<=a<=100:
    i="A"
elif 80<=a<90:
    i="B"
elif 70<=a<80:
    i="C"
elif 60<=a<70:
    i="D"
else:
    i="E"
print("你的成绩是：{}\n等级是：{}".format(a,i))
```

    请输入成绩：45
    你的成绩是：45
    等级是：E
    


```python
#上面的例子还可以这样去写

a=eval(input("请输入成绩："))

if a>100 or a<0 :
    print("输入错误,请重新输入") 
else:
    if 100>=a>=90:
        i="A"
    elif a>=80:
        i="B"
    elif a>=70:
        i="C"
    elif a>=60:
        i="D"
    else:
        i="E"
print("你的成绩是：{}\n等级是：{}".format(a,i))
```

    请输入成绩：87
    你的成绩是：87
    等级是：B
    

    **重点注意**
        多分支结构一定要注意条件之间的包含关系
        注意变量取值范围的覆盖
        
        如果不注意这些，虽然程序可以运行，但是逻辑是错误的
        （注意在设置不同的条件时候，它的先后关系及包含关系一定要弄明白）

#### **条件判断——操作符**

    分支语句中需要大量的调价判断，那么python提供了一些操作符，来对条件进行判断，并且产生真or假的结果

**如下：**

|操作符|数学符号|描述|
|------|--------|----|
|<|<|小于|
|<=|≤|小于等于|
|>=|≥|大于等于|
|>|>|大于|
|==|=|等于|
|!=|≠|不等于|

**用于条件组合的三个保留字**

|操作符及应用|描述|
|-----|------|
|x and y|两个条件x和y的逻辑与|
|x or y|两个条件x和y的逻辑或|
|not x|条件x的逻辑非|

## if语句 

编程时经常需要检查一系列条件，并据此决定采取什么措施。

在Python中，if语句让你能够检查程序的当前状态，并据此采取相应的
措施。


```python
cars = ['audi', 'bmw', 'subaru', 'toyota']
for i in cars:
    if i=='bmw':
        print(i.upper())
    else:
        print(i.title())
#这个例子主要说将list中的元素打印出来，如果第二个元素是“bmw”将其打印出为大写
#其他元素打印为首字母大写
```

    Audi
    BMW
    Subaru
    Toyota
    

## 条件测试 

每条if语句的核心都是一个值为True或False的表达式，这种表达式被称为条件测试。

Python根据条件测试的值为True还是False来决定是否执行if语句中的代码。

如果条件测试的值为True，Python就执行紧跟在if语句后面的代码；如果为False，Python就忽略这些代码。


## 检查多个条件 

你可能想同时检查多个条件，例如，有时候你需要在两个条件都为True时才执行相应的操作，
而有时候你只要求一个条件为True时就执行相应的操作。在这些情况下，关键字and和or可助你
一臂之力。


## 程序异常处理

### **异常处理的基本使用**

try：

    <语句块1>
    
except：

    <语句块2>
    
**说明**

我们把一块要执行的程序放在try语句对应的<语句块1>；

如果程序异常，那么程序就执行except<语句块2>；

如果程序不出现异常，那么我们就不执行<语句块2>；

为了进一步去区分不同的异常类型，我们可以在except中增加一个异常类型标记；

只有在这种类型发生时，才会执行<语句块2>


```python
# for example1：
try:
    num=eval(input("请输出一个整数："))
    print(num**2)
except:
    print("输入不是整数") #在except添加一条提示信息，一旦程序运行发生了异常，try 会接受着个异常，并会执行except部份的语句
```

    请输出一个整数：56
    3136
    

进一步我们也可以指定异常处理的异常类型，我们可以在except后面直接增加异常的名字

所有异常类型都是Python语言中预定义的，因此我们可以直接在except后面加上异常的名字来标明

针对这种异常我们去执行相应的语句块

**如果一旦我们在except后面增加了异常类型，后续语句块就只能响应这一个类型的异常**

**异常的类型时Python程序内部定义的，它不同于变量，所以我们不许要对它增加字符串表示**

只需给出NameError即可

掌握了try except和 try except异常类型名称，这两种基本的方法就能够应付大量的异常处理情况


```python
# for example2：
try:
    num=eval(input("请输出一个整数："))
    print(num**2)
except NameError:  #一旦我们在except后面增加了异常类型，后续语句块就只能响应这一个类型的异常
    print("输入不是整数")
```

    请输出一个整数：43
    1849
    

Traceback (most recent call last):

  File "F:\Anaconda\lib\site-packages\IPython\core\interactiveshell.py", line 3326, in run_code
    
    exec(code_obj, self.user_global_ns, self.user_ns)

  File "<ipython-input-62-d9ef285ff387>", line 3, in <module>   #表明异常在第几行
    
    num=eval(input("请输出一个整数："))

  File "<string>", line 1
    
    23d
      ^
SyntaxError: unexpected EOF while parsing   #表明异常类型

### 异常处理高级用法

try:
    
    <语句块1>
    
except：

    <语句块2>
   
else:

    <语句块3>
    
finally:

    <语句块4>
    
**说明**

●无论前面是否发生异常，finall对应<语句块4>一定会去执行

●else对应的语句块3在不发生异常时执行

通俗来讲：我们首先去执行<语句块1>的一部分代码

    如果它不发生异常，程序就去执行<语句块3>
    
    如果它发生异常，程序就去执行<语句块2>
    
    无论是否发生异常，程序都会执行<语句块4>
    
通过这种方式Python增加更多的异常处理相关逻辑，使得异常处理变得很棒

一般情况下掌握 try except就可以对应异常处理了


### 总结

程序的控制结构

单分支if 二分支 if—else及紧凑型形式

多分支if-elif-else及条件之间的关系 

在条件判断中的三个保留字 and not or   >,>=,>'<=,==;!=

异常处理：try-except-else-finally

**举例：**

    身体质量指数BMI（Body Mass Index)
    
    BMI:对身体质量的刻画
    
    国际上常用的衡量人体肥胖和健康标准程度的重要性，重要用于统计分析
    
  定义：BMI=体重(Kg)/身高($^2$)(m$^2$)
  
  标准：国际标准
  
 |分类|国际BMI值（Kg/m$^2$）|国内值（kg/m$^2$）|
 |------|-------|-------|
 |偏瘦|<18.5|<18.5|
 |正常|18.5~25|18.5~24|
 |偏胖|25~30|24~28|
 |肥胖|≥30|≥28|
 
 **设计问题需求**
 
     输入：给定身高和体重
     输出：BMI指标分类信息（国际和国内）
**设计算法**

    在算法部份要处理输出结果对应国际和国内部份 


```python
#计算如下：

height,weight=eval(input("请你输入体重（Kg）和身高(米)[两个用英文逗号分开]"))

#根据输入的值计算bmi值
bmi=weight/(pow(height,2))
print("BMI值为：{:.2f}".format(bmi))

who,net="",""
if bmi<18.5:
    who,net="偏瘦","偏瘦"
    
elif 18.5<=bmi<24:
    who,net="正常","正常"    
elif 24<=bmi<25:
    who,net="正常","偏胖"

elif 25<=bimi<28:
    who,net="偏胖","偏胖"
elif 28<=bmi<30:
    who,net="偏胖","肥胖"
    
else:
    who,net="肥胖","肥胖"

print("BMI指标是：国际：{0} 国内：{1}".format(who,net))    
```

    请你输入体重（Kg）和身高(米)[两个用英文逗号分开]62,168
    BMI值为：0.04
    BMI指标是：国际：偏瘦 国内：偏瘦
    

**注意**

①多分支条件之间的覆盖是重要问题

②程序可运行，但不正确，要注意多分支

③分支结构是程序的重要框架，读程序先看分支

### 程序循环结构

**遍历循环**

**无限循环**

**循环控制保留字**

**循环的高级用法**

在Python中只提供2种循环，遍历循环（对应保留字for） and 无限循环（保留字while）

#### 遍历循环

遍历循环是指遍历某个结构形成一个循环性方式

**格式**

for <循环变量>in<遍历结构>：

    <语句块>    #这里要使用缩进
    
它可以从遍历结构种逐一提取元素，放在循环变量中

由保留字for 和 in 组成，完整遍历所有元素后结束

每次循环，所获得元素放入循环变量，并执行一次语句块

#### 遍历循环应用

##### 计数循环（N次）

    for i in range(N,M,K):
        
        <语句块>

遍历由range()函数产生的数字序列，序列包含N个元素，每个元素是一个整数，分别是0，1一直到N-1


```python
#for example1  循环举例

for i in range(5):  #计算机计数是从0开始
    print(i,"\t",end="")

```

    0 	1 	2 	3 	4 	


```python
#for example2  循环举例

for i in range(1,6):
    print(i)
```

    1
    2
    3
    4
    5
    


```python
#for example3 循环举例（计数循环）

for i in range(1,6,2):   #这里面的2为步长
    print(i)
```

    1
    3
    5
    

#### 字符串循环

通过for  in range组合 我们可以实现计数循环，这是遍历循环的一种应用

同时遍历循环也可容易应用在字符串上

    for c in s：
        
        <语句块>
    其中s是一个字符串，遍历字符串中的每一个字符，产生循环
    
    c 代表字符串中的每一个字符
    
    它能够按顺序取出字符串中的每一个字符，放在c中
    
    


```python
#for example3 循环举例（字符串循环遍历）

for c in "Hello word":
    print(i,end=",")
```

    5,5,5,5,5,5,5,5,5,5,

#### **list遍历循环**

**语法**

    for item in ls：
    
        <语句块>
 其中ls是一个列表，遍历每个元素，产生循环


```python
#for example3 循环举例（list遍历循环）

for item in ["hello",123,"Questeryu"]:
    print(item,end=",")
```

    hello,123,Questeryu,

#### 文件遍历循环

 **语法**
 
        for line in fi：
        
            <语句块>
 fi是一个文件标识符，遍历其每一行，产生循环
 
 **文件标识符**我们可以对一个外部文件通过Python的函数将文件打开，
 
 如果文件时字符形式打开，它就会标识一个文件标识名字
 
 如果用一个变量来标识系统中的一个文件，这个变量就叫文件标识符

#### 无限循环 （ 条件循环）

无限循环是由条件控制的循环运行方式

简单来说它不是遍历某个结构，而是根据条件来循环

**语法**

    while <条件>：
    
           <语句块>
           
如果条件成立下面的语句将会被执行，执行后再次判断条件

如果条件还是成立，它会继续执行下面的语句，然后再返回循环

所以条件循环，是满足条件的情况下继续循环


```python
#for example 条件循环

a=5
while a>-5:
    a=a-1
    print(a,end=",")
```

    4,3,2,1,0,-1,-2,-3,-4,-5,

#### 循环控制保留字 

**break and continue**

**break** 跳出并结束当前整个循环，执行循环后面的语句

**continue**结束当次循环，继续执行后续次数的循环

**break and continue**可以与for循环及while循环搭配使用

##### continue and break


```python
# for example contine

for c in "Hello word":
    if c=="r":    #当遍历循环遇到c=="r"时，跳过这次的遍历循环，继续执行下一次循环
        continue
    print(c,end=",")
```

    H,e,l,l,o, ,w,o,d,


```python
# for example break

for c in "Hello word":
    if c=="r":    #当遍历循环遇到c=="r"时，跳出循环，执行循环以外的代码
        break
    print(c,end=",")
```

    H,e,l,l,o, ,w,o,


```python
i=0
s="python"
while s !="":
    for c in s:
        i=i+1
        print(c,end=",")
    s=s[:-1]
#    i+=1
print(i)
```

    p,y,t,h,o,n,p,y,t,h,o,p,y,t,h,p,y,t,p,y,p,21
    

#### 循环的高级用法

扩展用法  循环与else的搭配

我们知道else是用来做条件判断的

它可以和循环嵌套使用

在 for 循环后面可以增加一个else部分

##### **循环for and else**

    for <循环变量> in <遍历循环>：
    
        <语句块1>
        
    else：
    
        <语句块2>
        
##### **循环while and else**

    while <条件>：
    
        <语句块1>
        
    else：
    
        <语句块2>
        
##### **循环与else**

当循环与没有被break语句退出时，执行else语句块

简单来说 else语句块可以作为循环完成正常运行时的奖励

相当于异常处理中的else======>try except
        


```python
# for example 
a="ptython"
a=a.upper()
for c in a :
    if c=="T":
        continue
    print(c,end=",")
else:
    print("\n 正常退出")
```

    P,Y,H,O,N,
     正常退出
    


```python
# for example 
a="ptython"
a=a.upper()
for c in "PTHON" :
    if c=="T":
        break
    print(c,end="")
else:
    print("\n 正常退出")

#由于大写字符串中包含大写“T”，因此break一定会被执行
#执行之后，else部分正常退出语句就不会被执行
#因此通过else扩展，我们能够知道一段循环中是否被break结束
#这样对于我们进行程序逻辑设计更加便捷
```

    P

## 用户输入和while循环

大多数程序都旨在解决最终用户的问题，为此通常需要从用户那 里获取一些信息。

例如，假设有人要判断自己是否到了投票的年龄， 要编写回答这个问题的程序，就需要知道用户的年龄，这样才能给出 答案。

因此，这种程序需要让用户输入其年龄，再将其与投票年龄进 行比较，以判断用户是否到了投票的年龄，再给出结果。

这里要介绍一个函数==========>input()

### 函数input()的工作原理

函数input()让程序暂停运行，等待用户输入一些文本。

获取用户输入后，Python将其存储在 一个变量中，以方便你使用。

例如，下面的程序让用户输入一些文本，再将这些文本呈现给用户：


```python
#==============>注意在Jupyter NotBook中输入后再次按‘Ctrl’+‘enter’程序方可执行下一步
message=input("")
print(message)
```

    Questeryu
    Questeryu
    

### 编写清晰的程序

每当你使用函数input()时，都应指定清晰而易于明白的提示

准确地指出你希望用户提供 什么样的信息——指出用户该输入任何信息的提示都行，如下所示：


```python
name = input("Please input your name: ")
print("Hello, " + name +" I ♥ U" " !")
```

    Please input your name: Questeryu
    Hello, Questeryu I ♥ U !
    

### 使用intput()来获取数值输入


```python
#使用函数input()时，Python将用户输入解读为字符串。
age=input("how old are you?")
print(age)
print(type(age)) #可以看到输出的数字时字符串类型
#接下来我们要验证输入的是字符还是数字 如下：（数字可以进行加减运算，而字符串是不可以的）
age=age+1  #见程序报错=====>can only concatenate str (not "int") to str
print(age)
```

    how old are you?31
    31
    <class 'str'>
    


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-143-094a695ac103> in <module>
          4 print(type(age)) #可以看到输出的数字时字符串类型
          5 #接下来我们要验证输入的是字符还是数字 如下：（数字可以进行加减运算，而字符串是不可以的）
    ----> 6 age=age+1  #见程序报错=====>can only concatenate str (not "int") to str
          7 print(age)
    

    TypeError: can only concatenate str (not "int") to str



```python
#对于上面的程序，我们怎么处理呢？根据它的报错，进行类型转化 srt转化为int 如下：
age=input("how old are you?")
print(age)
print(type(age)) #可以看到输出的数字时字符串类型
#==================进行类型转化=================================
age=int(age)  #将str型转化为int型 这个样子就可以进行运算了
age=age+1 
print(age)
#在这里主要涉及到关于关于类型的转化的的相关运算
```

    how old are you?23
    23
    <class 'str'>
    24
    

### 求模运算符（说白了 就是取余）

处理数值信息时，求模运算符（%）是一个很有用的工具，它将两个数相除并返回余数：

这个怎么讲啊，没有什么东西可以讲啊.

这个是小学数学，就说10除以3商和余数是set少，不要给我说你不会 

如果你真的不会，相信你也不会看到这里的 这里要注意的一点就是============>被除数不等于零 如下：


```python
a=10%0
print(a)
```


    ---------------------------------------------------------------------------

    ZeroDivisionError                         Traceback (most recent call last)

    <ipython-input-145-c7252fc515a1> in <module>
    ----> 1 a=10%0
          2 print(a)
    

    ZeroDivisionError: integer division or modulo by zero



```python
x=10%3  #取余也就是求模RUN
print(x)
```

    1
    

## while 循环简介

for循环用于针对集合中的每个元素都一个代码块，而while循环不断地运行，直到指定的条 件不满足为止。

### 使用while 循环


```python
#你可以使用while循环来数数， 如下：
a=1
while a<=5:
    print(a)
    a+=1
```

    1
    2
    3
    4
    5
    

让用户选择何时退出

这里我们程序中设计一个退出的功能

#告诉程序当输入某个值的情况下，就退出当前的while循环

#那么我们就设计一个退出的条件：while a!=“你好”的时候退出当前的while循环 如下： a=0 while a!="你好":#如果程序条件为False
a=input() if a !="你好": print (a) print ("循环结束")


### 在循环中使用continue和break

要返回到循环开头，并根据条件测试结果决定是否继续执行循环，

可使用continue语句，它 不像break语句那样不再执行余下的代码并退出整个循环。

例如，来看一个从1数到10，但只打印 其中偶数的循环：


```python
#continue的使用 如下：
a=0
while a<11:
    a+=1
    if a%2!=0:  #如果这里是“a%2==0 那么它打印出来的就是奇数循环
        continue  #如果if条件成立就执行 ‘Continue'后======>执行while循环
    print(a,end="\t")
```

    2	4	6	8	10	


```python
#break的使用（break是直接结束了这个循环，
a=-1
while a<11:
    a+=1
    if a%2!=0:
        break 
    print(a)
```

    0
    

### 避免无限循环

每个while循环都必须有停止运行的途径，这样才不会没完没了地执行下去。例如，下面的 循环从1数到5：


```python
x=1
while x<=5:
    print(x)
    x+=1  #如果程序缺少这一个步骤的话，程序将会无限的运行下去
#每个程序员都会偶尔因不小心而编写出无限循环，在循环的退出条件比较微妙时尤其如此。
#如果程序陷入无限循环 可以按停止按钮来结束循环，（这里根据编译器的不同结束方法也不相同，这里请百度）
```

    1
    2
    3
    4
    5
    

## 使用while 循环来处理列表和字典

到目前为止，我们每次都只处理了一项用户信息：获取用户的输入，再将输入打印出来或作 出应答；循环再次运行时，我们获悉另一个输入值并作出响应。然而，要记录大量的用户和信息， 需要在while循环中使用列表和字典。 for循环是一种遍历列表的有效方式，但在for循环中不应修改列表，否则将导致Python难以 跟踪其中的元素。要在遍历列表的同时对其进行修改，可使用while循环。通过将while循环同列 表和字典结合起来使用，可收集、存储并组织大量输入，供以后查看和显示。

===这点要记住了哦=====>要在遍历列表的同时对其进行修改，可使用while循环。通过将while循环同列表和字典结合起来使用，可收集、存储并组织大量输入，供以后查看和显示。


### 在列表之间移动元素


```python
unconfirmed_users = ['alice', 'brian', 'candace']
confirmed_users = []
# 验证每个用户，直到没有未验证用户为止
# 将每个经过验证的列表都移到已验证用户列表中
while unconfirmed_users:
    current_user = unconfirmed_users.pop()
    print("Verifying user: " + current_user.title())
    confirmed_users.append(current_user)
# 显示所有已验证的用户
print("\nThe following users have been confirmed:")
for confirmed_user in confirmed_users:
      print(confirmed_user.title())
```

    Verifying user: Candace
    Verifying user: Brian
    Verifying user: Alice
    
    The following users have been confirmed:
    Candace
    Brian
    Alice
    


```python
#进行一个数据迁移吧（将A列表中的数据迁移到B别表中）如下：
A=['we','er','tyr','yiuytr','dgh','uhg','sdfs']
B=[]
while A:
    C=A.pop()   
    B.append(C.title())
print("A列表是：",A)
print("B列表是：",B)
#可以看到完整的将A列表中的数据迁移到B列表中
```

    A列表是： []
    B列表是： ['Sdfs', 'Uhg', 'Dgh', 'Yiuytr', 'Tyr', 'Er', 'We']
    

### **总结**

① for in 遍历循环：计数，字符串，列表，文件...

②while 无限循环

③continue and break 保留字：退出当前循环层次

④循环else的高级用法：和break有关

# random库的概述（随机函数）

python标准库 随着Python的解释器自带，不需要安装 直接使用import来使用

从哲学角度来考虑，随机数是随机产生的一些数据 真正的随机数也是在各种条件下产生的确定值

只不过这些复杂条件我们并不能充分了解or 已经超越我们的理解能力了

计算机无法产生随机数，但它可以产生伪随机数

伪随机数：采用梅森旋转算法生成的（伪）随机序列中元素 

random库主要用于生成随机数

使用方法：import random

## **random库包含两类函数，常用的共8个**

### **基本随机函数：**seed(),random()



```python
import random

random.seed(10)
random.random() 
for i in range(15):
    print(random.random(),end="\n")
```

    0.4288890546751146
    0.5780913011344704
    0.20609823213950174
    0.81332125135732
    0.8235888725334455
    0.6534725339011758
    0.16022955651881965
    0.5206693596399246
    0.32777281162209315
    0.24999667668640035
    0.9528169091459117
    0.9965569925394552
    0.04455638245043303
    0.860161037286291
    0.603190610968185
    

### **扩展随机函数：**randint(),getrandbits(),nuifrom(),randrange(),choice(),shuffle()



|函数|描述|用法|
|----|----|----|
|randint(a,b)|生成[a,b]之间的整数|random.randint(10,100)|
|randrange(m,n[,k)]|生成一个[m,n)之间以k为步长的随机整数|random.randrange(10,100,10)|
|getrandbits()|生成一个k比特步长的随机数|random.getrandbits(16)|
|nuifrom(a,b)|生成[a,b]之间的随机小数|random.uniform(10,100)|
|choice(seq)|从序列seq中随机选择一个元素|random.choic([1,2,3,4,5,7,6])|
|shuffle(seq)|将序列seq中的元素随机排列，返回打乱后的序列|s=[1,2,5,4,6,8,9,3]|
|||random.shuffle(s)|
|||print(s)|  

#### 要点(需要掌握)

①能够利用随机数种子产生"确定"伪随机数

②能够产生随机整数

③能够对序列类型进行随机操作

### **随机数种子**：只要是种子相同，它们产生的随机序列都是相同的

        所以随机数种子确定了随机序列的产生
        
|函数|描述|用法|
|----|----|----|
|seed()|初始化给定的随机种子，默认为当前系统时间|使用方法：random.seed(10)|
|random()|生成一个[0.0,1.0)之间的随机小数|使用方法：random.random()|








    

## 圆周率的计算


```python
#数学公式求解
pi=0
N=900

for k in range(N):
    pi+=1/pow(16,k)*(\
                    4/(8*k+1)-2/(8*k+4)-\
                    1/(8*k+5)-1/(k+6))
print("圆周率值是：{}".format(pi))
```

    圆周率值是：3.1367974603270943
    


```python
#蒙特卡罗方法求解圆周率
from random import random
from time import perf_counter  #程序运行计时
DARTS = 3000*3000
hits = 0.0
start = perf_counter()
for i in range(1,DARTS+1):
    x,y = random(),random()
    dist = pow(x**2+y**2,0.5)   #点到圆心的距离
    if dist <=1.0:    #如果点在圆心内，
        hits=hits+1    
pi=4*(hits/DARTS)

print("圆周率值是：{}".format(pi))
x = perf_counter()
c= x-start
print(c)
```

    圆周率值是：3.142605777777778
    12.178232199999911
    

科学家做过大量统计：一个程序运行的大部分时间or80%的时间，只消耗在不到10%的代码上

（有点像八二法则）其实这10%的代码就是循环代码

因此一个程序 他的主要运行时间都花在循环上

我们看待一个程序运行时，从性能角度来讲关注循环

如果自己编写的程序运行了很久，那么我们可以用per_counter

用time库来对其中的循环进行测量，看看是不是循环占用来大量的时间

可能对于一些小的程序，CPU运行速度很快，我们并不是很关心，但是这样的习惯真的不好

虽然可能是那么几纳秒，如果把它累计，它能够减少你生命的浪费

无论是大的还是小的事情，往往是那些很微小很微小的部分的积累导致了异常！

请关注微小的事物，正如苏世民说：做大事和做小事的难度是一样的，都会消耗你的时间和精力，

所以如果决心做事，就要做大事，要确保你的梦想值得追求。”

## 函数和代码定义和使用


### 函数的理解与定义

函数是一段具有特定功能的可重用的语句组

函数是一种功能的抽象，一般函数表达特定功能

两个功能：降低编程难度 和 代码复用

        函数是一段代码的表示
        
        def <函数名>(<参数(0个or多个)>)：
        
            <函数体>
            return<返回值>


```python
# 计算n!
def fact(n):
    s=1
    for i in range(1,n+1):
        s*=i
    return(s)
fact(5)
```




    120




```python
def facts(m,n):
    s=1
    for i in range(m,n+1):
        s*=i
    return s
facts(3,5)
```




    60



#### **可选参数传递**

函数定义时可以为某些参数制定默认值，构成可选参数

    def <函数名>（<非可选参数><可选参数（可有可无）>）:  #非可选参数要放在最前面，可有可无放在后面
    
        <函数体>
        
        return<返回值>
        
### **可变参数传递**

函数定义时，可以设计可变量参数，即不确定参数总量

    def <函数名>（<参数>，*b）：
    
        <函数体>
        return <返回值>
        
### **函数的返回值**

我们知道函数可以返回零or多个值 其中使用return来传递返回值

函数可有返回值，也可没有，可有return 也可以没有

如果函数不想输出任何值，那么给出return 即可


```python
def fact(n,m=1):
    s=1
    for i in range(1,n+1):
        s*=i
    return s//m,n,m
fact(10,5)

```




    (725760, 10, 5)



### 局部变量和全局变量

如下有一段程序，中间有一个函数定义

其中使用的变量叫全局变量

而在函数定义的函数体中使用的变量叫局部变量

全局和局部的区别仅在于 局部是函数内部使用的变量

    <语句块>
    
    def <函数名>（<参数>）：
    
        <函数体>
        
        return <返回值>
        
    <语句块2>
    


#### **局部变量和全局变量是不同的变量**

    局部变量是函数内部的占位符，与全局变量重名但不同
    
    函数运行结束，局部变量被释放（所谓的释放：就是这个变量不存在，只是用于函数内部运算）
    
    我们也可以使用global保留字在函数内部使用全局变量
    
#### **规则1：局部变量为组合数据类型且未创建，等同于全局变量**




```python
#规则1：局部变量和全局变量是不同的变量
n,s = 10,100
def fact(n):
    s=1             #fact()函数中的s是局部变量，与全局变量s不同
    for i in range(1,n+1):
        s*=i
    return s      #这里的局部变量s=3628800 
print(fact(n),s)   #这里的全局变量s=100
```

    3628800 100
    


```python
#使用globle保留字来声明全局变量

n,s = 10,100
def fact(n):
    global s             #声明函数中的s为全局变量
    for i in range(1,n+1):
        s*=i              
    return s            #这里的全局变量s=3628800
print(fact(n),s)   
```

    362880000 362880000
    

#### **规则2：局部变量为组合数据类型且未创建，等同于全局变量**


```python
#规则2：局部变量为组合数据类型且未创建，等同于全局变量
ls=['f','F']    #通过使用[]真实创建一个全局变量ls
def func(a):
    ls.append(a)  #此处ls为列表类型，为真实创建，等同于全局变量
    return 
func("c")       #全局变量ls被修改
print (ls)
```

    ['f', 'F', 'c']
    


```python
ls=['f','F']    #通过使用[]真实创建一个全局变量ls
def func(a):
    ls=[]       #此处ls为列表类型，为真实创建，ls是局部变量
    ls.append(a)  
    return 
func("c")       #局部变量ls被修改
print (ls)
```

    ['f', 'F']
    

## **lambda函数**

lambda函数返回函数名作为结果

lambda函数是一种匿名函数，即没有名字的函数

使用lambda保留字定义，函数名是返回结果

lambda函数用于定义简单的，能够在一行内表达的函数

语法：

    <函数名>=lambda<参数>：<表达式>
    
等价于def and return 不同的是lambda函数后面只能用表达式，不能用函数体


```python
# for example lambda

a= lambda x,y:x+y

a(3,5)
```




    8



lambda函数主要运作一些特定函数or方法参数

lambda函数有一些固定的方式，建议逐步掌握

一般情况下建议使用def定义的普通函数

### Lambda 表达式
写一个很短的函数可以用 lambda 关键字。

下面是用 def 关键字写函数：



```python
def add(x,y):
    return x+y
add(3,5)
```




    8



**下面是用 lambda 关键字写函数：**


```python
add=lambda x,y:x+y
add(3,5)
```




    8



lambda 的语法结构如下：

lambda_expr ::= "lambda" [parameter_list] ":" expression
注意： lambda 语句中， : 之后有且只能有一个表达式

而这个函数呢，没有名字，所以被称为 “匿名函数”。

作为某函数的返回值


```python
def make_incrementor(n):
    return lambda x: x + n
f = make_incrementor(42)
f(0)
f(1)
```




    43



这个例子乍看起来很令人迷惑。我们先看看 f = make_incrementor(42) 之后， f 究竟是什么东西：


```python
def make_incrementor(n):
    return lambda x: x + n
f = make_incrementor(42)
f
id(make_incrementor)
id(f)
```




    2538203106040



那 f 是什么呢？它是 <function main.make_incrementor..(x)> ：

    f = make_incrementor(42) 是将 make_incrementor(42) 的返回值保存到 f 这个变量之中；
    而 make_incrementor() 这个函数接收到 42 这个参数之后，返回了一个函数： lambda x: x + 42 ；
    于是， f 中保存的函数是 lambda x: x + 42 ；
    所以， f(0) 是向这个匿名函数传递了 0 ，而后，它返回的是 0 + 42 。

## 代码复用与函数递归

### **⚪代码复用与模块化设计**



我们可以使用函数or对象，通过封装将功能进一步抽象化

通过这些高层次的封装可以完成更高层的功能设计

在代码复用的基础上，程序员可以开展模块化设计

模块化设计：基于一种逻辑的设计思维（分而治之）

我们可以使用函数or对象，通过封装将程序划分为模块以及模块之间的表达

对我们要实现的算法，如果设定了功能模块，并且在功能模块之间建立之间的关系

那么一个程序就能表达清楚

在模块化设计思想中：关注程序的主程序，子程序，以及子程序之间的关系

我们一般将子程序看作模块  主程序看作模块与模块之间的关系

分而治之的思想是模块化设计的核心，也可以说模块化设计是一种分而治之，分层抽象，体系化的设计思想


模块化设计有2个基本的概念：紧耦合和松耦合

**紧耦合：两个部分之间的交流很多，无法独立存在，那么这两个部分就是紧耦合的模式**

**松耦合：两个部分之间的交流很少，可独立存在**


### **⚪函数递归的理解**

在函数定义中，调用函数自身的方式就叫递归

递归不是函数设计的新名词，它在数学中也广泛存在 

**链条和基例**

#### **链条：所谓的链条是指在递归定义中，它的计算过程是存在一种递归有序的链条关系**

#### **基例：存在一个or多个不需要再次递归的基例**

递归在数学上的说法叫数学归纳法

#### **数学归纳法**

证明当n取第一个值:n0 时，命题成立

假设当nK时，命题成立，证明n=n(k+1)时命题也成立

如果这两个都成立，那么我们证明是正确的

因此说递归也是数学归纳法思维的编程体现



#### **函数递归的调用过程**

如何利用Python实现递归？

**递归的实现：函数+分支语句**

⚪递归本身是一个函数，需要函数定义方式描述

⚪函数内部，采用分支语句对输入参数进行判断（那些时基例，那些时链条）

⚪基例和链条，分别编写对应代码

通过函数递归，代码复用，我们可以利用更少的代码来完成更多的功能，这将会大大提高我们的编程思想和效率


```python
# 递归的实现
def fact(n):
    if n==0:
        return 1
    else:
        return n *fact(n-1)

fact(5)
```




    120



**递归的实现如下图：**
![title](C:/Users/QUESTERYU/Desktop/PY编程图片/递归.JPG)

### PyInstaller 库的概述

将.py源代码转化成无需源代码的可执行文件（windows，linux，mac OS X）

#### PyInstaller库的安装

（cmd命令行）pip install pyinstaller

运行时需要链接互联网

安装其他模块也是一样的

安装完成后会提示：“Sucessfuly installed”说明安装成功

#### PyInstaller的使用说明

PyInstaller安装完成后会生成一个文件，也是一个命令：PyInstaller

通过这个命令 将源程序打包（封装）生成可执行文件

在cmd命令行下 pyinstaller -F <文件名.py>  生成的文件在 dist文件中

这个文件就是打包后的文件，我们可以双击进行RUN

#### PyInstaller的常参数

|参数|描述|
|----|----|
|-h|查看帮助|
|--clean|清理打包过程中的临时文件|
|-D,onedir|默认值，生成dist文件|
|-F，onefile|在dist文件中生成独立的打包文件|
|-i<图标文件名.ico>|制定打包程序使用的图标（ico）文件 |

**PyInstaller -i <图标文件名.ico> -F <文件名.py>**   #生成一个带图标的可执行文件

# 组合数据类型(集合 序列 元组 字典)

组合数据类型的结构：集合类型，序列类型和字典类型 

## 集合类型及操作

### 集合类型的定义

集合：集合时多个元素的无序组合（集合类型与数学概念中的集合概念一致）

**①集合中的每个元素唯一，不存在相同元素**

②集合元素不可更改，不能时可变数据类型（不可变数据类型：一旦放入集合中，这个元素时不可以修改的）

③因为集合中的每个元素都是独一无二的，因此一旦发生修改，出现元素同名，那么会导致错误，

so 集合必须是非可变数据类型 非可变类型 整数，复数，浮点数，字符串类型，元组

在Python中集合用大括号{}表示，元素之间用逗号分割

    建立集合类型用{}or set()  
    
    如果建立一个空集合时必须使用set()



```python
#集合举例
A={"Hello word",123,("Questeryu",456)} #使用{}建立集合
A
```




    {('Questeryu', 456), 123, 'Hello word'}




```python
#当然我们也可以shi'当然我们也可以使用set()

#由于"pypypupy1223"中出现了重复的字符，生成集合之后，相同的字符只保留1个
B=set("pypypupy1223")  #set函数将字符串单独拆分，变成集合 ，集合中没有顺序

B
```




    {'1', '2', '3', 'p', 'u', 'y'}



### 集合操作符

|操作符及应用|描述|
|------|------|
|S"|"T|返回一个新集合，包括在集合S和T中的所有元素|
|S-T|返回一个新集合,包括在集合S但不在T中的元素|
|S&T|返回一个新集合，包括同时在集合S和T中的元素|
|S^T|返回一个新集合,包括集合S和T中的非相同元素|
|S<=T or S<T|返回Ture/False，判断S和T的子集关系|
|S>=T or S<T|返回Ture/False,判断S和T的包含关系|


```python
S={"p","y",123}
T=set("pypy123")
print(S-T)  #返回一个新集合,包括在集合S但不在T中的元素
print(S|T)  #包括在集合S和T中的所有元素（并集）
print(S&T) #包括同时在集合S和T中的元素 (相当于交集)
print(S^T)  #查找S 和T中的不相同元素
```

    {123}
    {'y', '2', '3', '1', 123, 'p'}
    {'p', 'y'}
    {'1', 123, '2', '3'}
    

### 集合的处理方法

我们知道方法是用某个变量加“.”,这样的方式来调用函数，

对于集合如下：

|操作函数or方法|描述|
|-----|-----|
|S.add(x)|如果x不在集合S中，将x增加到S|
|S.discard(x)|移除S中元素x，如果x不在集合S中，不报错|
|S.remove(x)|移除S中元素x,如果x不在集合S中,产生KeyError报错|
|S.clear()|移除S中的所有元素|
|S.pop()|函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值|
|S.copy()|返回集合S的一个副本|
|len(S)|返回集合S的元素个数|
|x in S|判断S中元素x，x在集合S中，返回True值，否则返回False|
|x not in S|判断S中元素x，x不在集合S中，返回True值，否则返回False|
|set(x)|将其他类型变量x转变为集合类型|


```python
s={1,3,4,6}
s.pop()
```




    1




### 集合类型应用场景

集合类型应用在哪些场景中呢？

**包含关系的比较**

一个数据or 一组数据是否是另一个数据中，这时候我们要用集合来表达这组数据

并且对另外的数据or一组数据与这一组数据之间的关系进行比较


```python
#包含关系比较：
"Q"in {"Q","U","1","4","er"}
```




    True




```python
{"w","r","y"} >={"p","y"}  #数据之间的比较
```




    False



**典型应用（数据去重）**

要点：利用集合中所有元素不能重复的特点，

对一组数据中的重复元素进行删除


```python
A=["p","p","e","w"] # list类型
set(A)   #转换成集合类型

#如果想要保持原来的集合类型 如下：

list(set(A))

```




    ['e', 'p', 'w']



### 集合类型及操作（总结）

集合使用{}和set()函数创建

集合间的操作：交（&），并(|),差(-),补(^),比较(>=<)

集合类型方法：.add(), .discard(), .pop()等

集合类型主要应用：包含关系，数据去重

## 序列类型操作（元组和列表类型）

### 序列类型的定义

序列是具有先后关系的一组元素，与集合不同，序列元素之间存在先后关系

序列是一维元素向量，元素类型可以不同。

类似数学元素序列：S1，S2，S3，S(n-1)

正是因为元素之间存在相互关系，因此，元素之间可以相同，元素的类型可以不同

元素间由序号整数引导，通过下标访问序列的特定元素


### 序列处理函数及方法

序列类型有一些操作符和处理函数（部分在前面已经提到过）

**6个操作符**

|操作符及应用|描述|
|-----|-----|
|x in s|如果x是序列s的元素，返回True，否则返回False|
|x not in s|如果x是序列s的元素，返回False，否则返回True|
|s+t|连接两个序列s和t|
|s * n or n * s|将序列s复制整数n次|
|s[i]|索引，返回s中的第i个元素，i是序列的序号|
|s[i:j] or s[i:j:k]|切片，返回序列s中第i到j以k为步长的元素子序列|


```python
# 举例
ls=["python",123,"pypy"]
ls[::-1] #相当于序列取反
```




    ['pypy', 123, 'python']




```python
#类似之前我们学习的字符串取反
s="python"
s[::-1]
```




    'nohtyp'



### 序列类型通用函数和方法（5个）

|函数和方法|描述|
|------|-----|
|len(s)|返回序列s的长度|
|min(s)|返回序列s的最小元素，s中元素要可比较|
|max(s)|返回序列s的最大元素，s中元素要可比较|
|s.index(x) or s.index(x,ij)|返回序列s从i开始到j位置第一次出现元素x的位置|
|s.count(x)|返回序列s中出现x的总次数|

#### 元组定义

list适合储存在程序Run期间可变的数据集，list可以修改，

but sometimes 你需要创建一列不可修改的元素，元组可以满足这种需求，

Python将不能修改的值称为不可变的，而不可变的的list被称为元组。

元组类型是序列的扩展，本质上是序列类型

元组类型的每个元素一旦定义，元素的每个值是不可以修改的

**元组类型继承了序列类型的全部通用操作**

#### 定义元组（tuple）

元组看起来就像列表，但使用=====>圆括号<======而不是方括号来标识。定义元组后，就可以使用索引来
访问其元素，就像访问列表元素一样。


```python
names=("nihao","Alice","aruike","Tom","Bob")
print(names[2].title(),names[3],end="\t")
```

    Aruike Tom	


```python
#将元组转化成列表
names=("nihao","Alice","aruike","Tom","Bob")
tuple(names)
list(names)
```




    ['nihao', 'Alice', 'aruike', 'Tom', 'Bob']




```python
#将列表转化为元组
names=["nihao","Alice","aruike","Tom","Bob"]
tuple(names) #是将元组转化为list

```




    ('nihao', 'Alice', 'aruike', 'Tom', 'Bob')




```python
#下面进行一个元素值的修改
names=("nihao","Alice","aruike","Tom","Bob")
a=list(names)
print(a)
a[2]="linda"#这一句是在list中替换元素，而元组中的元素是不可以修改的 如下：
names[2]="linda"
print(names) #这一句会报错，原因是元组中的元素是不可以修改的
print(a)


```

    ['nihao', 'Alice', 'aruike', 'Tom', 'Bob']
    


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-182-4337968619d1> in <module>
          4 print(a)
          5 a[2]="linda"#这一句是在list中替换元素，而元组中的元素是不可以修改的 如下：
    ----> 6 names[2]="linda"
          7 print(names) #这一句会报错，原因是元组中的元素是不可以修改的
          8 print(a)
    

    TypeError: 'tuple' object does not support item assignment


**元组中的元素是不可以修改的**


```python

#如果真的要修改 这样：（我们可以把tuple变成list，然后在list中修改，然后转化成tuple！可以吗？）

names=("nihao","Alice","aruike","Tom","Bob")


#将tuple转化成list
a=list(names)


#在list中添加元素
a[2]="He"

#将修改后的list改编成tuple
print(tuple(a))

```

    ('nihao', 'Alice', 'He', 'Tom', 'Bob')
    


```python
#这也是一个元组
creature="apple","banana","orange"
creature[::-1]
print(creature)
```

    ('apple', 'banana', 'orange')
    

**这个也很重要（提示：这里的creature是一个元组）**


```python
creature="apple","banana","orange" #这是一个元组
a=("we","purple",creature)  # 这里的creature是一个元组，因此还可以对它进行操作
a[-1][2]     
```




    'orange'




```python
#"Apple"出现在列表中的索引
creature="apple","banana","orange"
creature.index("apple")
```




    0




```python
names=("nihao","Alice","aruike","Tom","Bob")
for i in names[::-1]: #这里你可以使用切片，选择性的遍历元组中的值
    print("{}".format(i))
print("\n")





for x in names:#这个是遍历元组中的所有值
    print(x)
```

    Bob
    Tom
    aruike
    Alice
    nihao
    
    
    nihao
    Alice
    aruike
    Tom
    Bob
    

## 什么是list（）
列表由一系列按特定顺序排列的元素组成。你可以创建包含字母表中所有字母、数字0~9或

所有家庭成员姓名的列表；也可以将任何东西加入列表中，其中的元素之间可以没有任何关系。

鉴于列表通常包含多个元素，给列表指定一个表示复数的名称（如letters、digits或names）is a good idea

在Python中，用方括号（[]）来表示列表，并用逗号来分隔其中的元素。下面是一个简单的例子


```python
#举个栗子（哈哈哈）
color=["yellow","black","red","green","purple"]
print(color)
#将每一个元素打印出来 这里利用一个循环吧
for i in color:
    #print (i)
#是不是很简单呢！

    print(i,end="\t")
```

    ['yellow', 'black', 'red', 'green', 'purple']
    yellow	black	red	green	purple	

### 访问list 元素


```python
#访问列表元素
test=[1,2,3,4,56,7,8,6,443,3,2,2,23,23,]
print(test[3])
```

    4
    


```python
bicycles = ['trek', 'cannondale', 'redline', 'specialized']
print(bicycles[0].title())   #将元素的首字母大写
```

    Trek
    


```python
print(bicycles[3].title()) #title 是将英文单词的首字母进行大写
print(bicycles[3].upper()) #upper 是将英文所有的都大写
print("\n",bicycles[3].lower()) #lower 是将英文小写

''''Python为访问最后一个列表元素提供了一种特殊语法。通过将索引指定为-1，可让Python返
回最后一个列表元素：'''
print(bicycles[-1])
print()
#这里要说明的是：Python 的索引是从零（0）开始的，这点请明确
```

    Specialized
    SPECIALIZED
    
     specialized
    specialized
    
    


```python
bicycles = ['trek', 'cannondale', 'redline', 'specialized']
a=len(bicycles)
for i in range(4):
    message="My fist bicycle was a "+bicycles[i].title()+"."
    print(message)
```

    My fist bicycle was a Trek.
    My fist bicycle was a Cannondale.
    My fist bicycle was a Redline.
    My fist bicycle was a Specialized.
    

### 修改、添加和删除元素 


```python
names=["万总","大和","奇数","你好"]
#我们修改list中的第一个元素 这里记住Python的索引是从零开始的
names[0]="大家"
print(names) #可以看到将list中的第一个元素（“万和”修改为“大家”）
```

    ['大家', '大和', '奇数', '你好']
    

###  在列表中添加元素（append）

在列表末尾添加元素

在列表中添加新元素时，最简单的方式是将元素附加到列表末尾。给列表附加元素时，

它将添加到列表末尾。继续使用前一个示例中的列表


```python
# append函数举例：
list=["Hello word","Python"]
list.append("Questeryu")  #添加元素
list
```




    ['Hello word', 'Python', 'Questeryu']



方法append()让动态地创建列表易如反掌。

例如，你可以先创建一个空列表，再使用一系列的append()语句添加元素。


```python
#创建一个空列表
users=[]
users.append("Jack")
users.append("Tom")
users.append("china")
print(users)
```

    ['Jack', 'Tom', 'china']
    

### 在列表中插入元素（insert）

使用方法insert()可在列表的任何位置添加新元素。为此，你需要指定新元素的索引和值。


```python
users.insert(0,"Alice")  #在列表中开头增加Alice
users
```




    ['Alice', 'Jack', 'Tom', 'china']



### 从列表中删除元素(del and pop) 

说明：“del”是删除list 中的元素，没有返回值=>del names[2] ===>删除第三个元素。

        （记住Python的索引是从零开始的）
        
        "pop"是删除list中的元素，并且有返回值====>names.pop[2]
        
        而"del"是没有返回值


```python
#  del 的使用方法
#这次我们还是使用上次的list====>names
users=['linda', 'Jack', 'Tom', 'china']
del users[0]
print(users)#可以看到将list中的第一个元素（“linda“删除了；
#使用del语句将值从列表中删除后，你就无法再访问它了
```

    ['Jack', 'Tom', 'china']
    


```python
#  使用 pop()进行元素的删除
#  有时候，你要将元素从列表中删除，并接着使用它的值。
#我们重新建立一个list 文件，顺便复习一下元素的添加和插入
#-----------------------------------------------------
#首先我们建立一个空的list
products=[]

#我们复习一下 append吧！
products.append("nihao") #每次只能添加一个元素=========>append

products.append(2)
products.append("中国")

#再复习一下在list中插入元素这个函数吧=====>insert

products.insert(1,"Videos")#括号中的“1”是索引“1”，也就是第2个元素，索引是从0开始的

#现在我们用pop()将第2个元素删除
a=products.pop(1)
products.pop(1)
print(products)
print("删除的值是:'{}'\nproducts list is:{}".format(a,products))  #设置指定位置，可以多次使用，这个可以查看1.1 print()函数
```

    ['nihao', '中国']
    删除的值是:'Videos'
    products list is:['nihao', '中国']
    

别忘了，每当你使用pop()时，被弹出的元素就不再在列表中了。

如果你不确定该使用del语句还是pop()方法，下面是一个简单的判断标准：如果你要从列表

中删除一个元素，且不再以任何方式使用它，就使用del语句；如果你要在删除元素后还能继续

使用它，就使用方法pop()。

### 根据值删除元素 remove()

有时候，你不知道要从列表中删除的值所处的索引位置。

如果你只知道要删除的元素的值，**可使用方法remove()。**


```python
#这次建立一个数字list吧
x=[1,2,3,5,3,2,4,5,4,4,34,53,5,54,35]
#现在用remove来删除list中的值
x.remove(2) #这里只删除元素中前面的一个值
print (x)
```

    [1, 3, 5, 3, 2, 4, 5, 4, 4, 34, 53, 5, 54, 35]
    

注意： 方法remove()只删除第一个指定的值。

如果要删除的值可能在列表中出现多次，就需要使用循环来判断是否删除了所有这样的值



```python
# 这个貌似有问题，#这里试着写一下，后面会学习的 ===============>这里用一个if 语句吧（了解）
x=[1,2,3,5,3,2,4,5,2,2,2,4,4,34,53,5,54,35]
a,b= 2,0

for i in x:
    if i==2:
        b+=1
        x.remove(2)
        
   

print(x)
print("\n共有'{}'{}个".format(a,b))
```

    [1, 3, 5, 3, 4, 5, 2, 4, 4, 34, 53, 5, 54, 35]
    
    共有'2'4个
    


```python
# 当然我们也可以使用count函数来确定value的个数
x=[1,2,3,5,3,2,4,5,2,2,2,4,4,34,53,5,54,35]

x.count(2)  #计算2在list中的个数

#当然也可以遍历每个元素知道它们的个数

#第一步：去重将list转化为集合set  集合定义：集合中的每个元素唯一，不存在相同元素
a=set(x)
for i in a:
    x.count(i)
    print("{}在{}中有{}".format(i,x,x.count(i)))
    
#当然你也可以根据数量多少来排序   应用于：词频统计
```

    1在[1, 2, 3, 5, 3, 2, 4, 5, 2, 2, 2, 4, 4, 34, 53, 5, 54, 35]中有1
    2在[1, 2, 3, 5, 3, 2, 4, 5, 2, 2, 2, 4, 4, 34, 53, 5, 54, 35]中有5
    3在[1, 2, 3, 5, 3, 2, 4, 5, 2, 2, 2, 4, 4, 34, 53, 5, 54, 35]中有2
    4在[1, 2, 3, 5, 3, 2, 4, 5, 2, 2, 2, 4, 4, 34, 53, 5, 54, 35]中有3
    5在[1, 2, 3, 5, 3, 2, 4, 5, 2, 2, 2, 4, 4, 34, 53, 5, 54, 35]中有3
    34在[1, 2, 3, 5, 3, 2, 4, 5, 2, 2, 2, 4, 4, 34, 53, 5, 54, 35]中有1
    35在[1, 2, 3, 5, 3, 2, 4, 5, 2, 2, 2, 4, 4, 34, 53, 5, 54, 35]中有1
    53在[1, 2, 3, 5, 3, 2, 4, 5, 2, 2, 2, 4, 4, 34, 53, 5, 54, 35]中有1
    54在[1, 2, 3, 5, 3, 2, 4, 5, 2, 2, 2, 4, 4, 34, 53, 5, 54, 35]中有1
    

#### 组织列表

元素的排列顺序常常是无法预测的，因为你并非总能控制用户提供数据

的顺序。这虽然在大多数情况下都是不可避免的，但你经常需要以特定的顺序呈现信息。

有时候，你希望保留列表元素最初的排列顺序，而有时候又需要调整排列顺序。Python提供了很多组织列

表的方式，可根据具体情况选用。

**使用方法sort()对列表进行永久性排序** 

**使用函数sorted()对列表进行临时排序**

#### 使用方法sort()对列表进行永久性排序

Python方法sort()让你能够较为轻松地对列表进行排序


```python
A=['数学','语文','地理','英语','化学','日本语']
A.sort()
print(A)
#方法sort()永久性地修改了列表元素的排列顺序。现在，科目是按字母顺序排列的，
#再也无法恢复到原来的排列顺序
```

    ['化学', '地理', '数学', '日本语', '英语', '语文']
    


```python
#可以将字符串反向传递出来，在这里只需要向函数sort（）传递参数reverse=True即可
A.sort(reverse=True)
print(A) #这个是对元素永久性的修改
```

    ['语文', '英语', '日本语', '数学', '地理', '化学']
    

#### 使用函数sorted()对列表进行临时排序 



```python
# 要保留列表元素原来的排列顺序，同时以特定的顺序呈现它们，可使用函数sorted()
print ("原始list是:{}\n 使用sorted函数后的list是:{}".format(A,sorted(A)))

#调用函数sorted()后，列表元素的排列顺序并没有变。如果你要按与字母顺
#序相反的顺序显示列表，也可向函数sorted()传递参数reverse=True。如下：
s=["a","C","F","d","e","ww"]
print(s)
print(sorted(s,reverse=True)) #“reverse”不是指按与字母顺序相反的顺序排列列表元素，
#而只是反转列表元素的排列顺序：=================>切记，切记，切记。。。。
```

    原始list是:['语文', '英语', '日本语', '数学', '地理', '化学']
     使用sorted函数后的list是:['化学', '地理', '数学', '日本语', '英语', '语文']
    ['a', 'C', 'F', 'd', 'e', 'ww']
    ['ww', 'e', 'd', 'a', 'F', 'C']
    

#### 基础排序
简单的升序排序非常容易：直接调用sorted()函数就可以了，它返回一个新的列表：


```python
sorted([5, 2, 3, 1, 4])
```




    [1, 2, 3, 4, 5]



也可以使用列表本身的方法list.sort()去排序。它会改变list的内容，然后返回None作为执行的结果，以避免混淆。一般来说它没有sorted()那么方便，但是如果你不需要原来的列表的话，使用它在性能上会有轻微的提升。


```python
a = [5, 2, 3, 1, 4]
a.sort()
a
```




    [1, 2, 3, 4, 5]



另一个区别就是，list.sort()方法只能用于列表，相对的，sorted()函数则适用于所有的可迭代对象，如：


```python
sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'})
```




    [1, 2, 3, 4, 5]



#### key函数

从Python2.4开始，无论是list.sort()还是sorted()都增加了一个key参数，指定一个在进行比较之前作用在每个列表元素上的函数。

例如，以下就是大小写不敏感的字符串比较：


```python
sorted("This is a test string from Andrew".split(), key=str.lower)
```




    ['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']



#### 倒着打印列表（reverse）


```python
# 使用reverse函数进行反转
#举个栗子
d=[1,2,3,6,7,8,6,5,4] 
#反向打印
d.reverse()  #反向排序
print(d) 
d.reverse()  #反向排序，回到原来的list顺序
print(d)
```

    [4, 5, 6, 8, 7, 6, 3, 2, 1]
    [1, 2, 3, 6, 7, 8, 6, 5, 4]
    

#### 字符串的长度计算 （len( )）


```python
f=d
print (f,"\n'f'字符串的长度是{}".format(len(f)))
```

    [1, 2, 3, 6, 7, 8, 6, 5, 4] 
    'f'字符串的长度是9
    

#### 使用列表避免索引错误



```python
#举例：
# list中有3个元素
e=[1,2,5]
print(e[3]) #这里的3是索引3，也就是第四个元素
```


    ---------------------------------------------------------------------------

    IndexError                                Traceback (most recent call last)

    <ipython-input-211-5698ba225de8> in <module>
          2 # list中有3个元素
          3 e=[1,2,5]
    ----> 4 print(e[3]) #这里的3是索引3，也就是第四个元素
    

    IndexError: list index out of range


**IndexError: list index out of range(list索引超出范围)**


```python
#=======================方法一=================================
# 如果你想访问list的最后一个元素
# ① 使用len（）函数获得字符串长度，最后一个元素的索引：len（）-1 如下：
a=e[len(e)-1]
print(a)
```

    5
    


```python
#=======================方法二=================================
#②在不知道元素个数的情况下可以使用[-1]
print(e[-1])
# 2种方法自己看情况使用
```

    5
    


```python
x=[]
#列表x不包含任何元素，因此Python返回一条索引错误消息：
print(x[-1])
```


    ---------------------------------------------------------------------------

    IndexError                                Traceback (most recent call last)

    <ipython-input-214-2dda8d82dcff> in <module>
          1 x=[]
          2 #列表x不包含任何元素，因此Python返回一条索引错误消息：
    ----> 3 print(x[-1])
    

    IndexError: list index out of range


**关闭程序前，务必消除这个错误。**

#### 列表类型及操作

列表是序列类型的扩展，它与元组类型很相似

列表是一种序列类型，创建后可以随意修改

使用[] or list()创建，元素间用逗号分割

列表中个元素类型可以不同，无长度限制

##### 列表类型及操作和函数方法

|函数or方法|描述|
|-----|-----|
|ls[i]=x|替换列表ls第i元素为x|
|ls[i:j:k]=lt|用列表ls替换切片后所对应的元素子列表|
|del ls[i]|删除列表ls中第i元素|
|del ls[i:j:k]|删除列表中从i到j以k为步长的元素|
|ls+=lt|更新列表ls，将列表lt元素增加到ls列表中|
|ls * = n|更新列表，其元素重复n次|



```python
colur=["yellow","purple","red","blue"]
colur[1:2]=[1,2,3,5]  #替换元素
print(colur)
```

    ['yellow', 1, 2, 3, 5, 'red', 'blue']
    


```python
colur=["yellow","purple","red","blue"]
del colur[::3]
colur
```




    ['purple', 'red']




```python
colur=["yellow","purple","red","blue"]
colur*2
```




    ['yellow', 'purple', 'red', 'blue', 'yellow', 'purple', 'red', 'blue']



#### 列表类型及操作和函数方法

|函数or方法|描述|
|-----|-----|
|ls.append(x)|在ls列表最后增加一个元素x|
|ls.clear()|删除列表中的所有元素|
|ls.copy()|生成一个新列表，赋值ls中所有元素|
|ls.insert(i,x)|在列表ls的第i位置增加元素x|
|ls.pop(i)|将列表ls中第i位置元素取出并删除该元素|
|ls.remove(x)|将列表ls中出现的第一个元素x删除|
|ls.reverse()|将列表ls中的元素反转|


```python
# 增加元素append()函数
colur=["yellow","purple","red","blue"]
colur.append("Green") # .append()在ls列表最后增加一个元素x
colur
```




    ['yellow', 'purple', 'red', 'blue', 'Green']




```python
#元素增加 insert()
colur=["yellow","purple","red","blue"]
colur.insert(1,"pink")
colur
```




    ['yellow', 'pink', 'purple', 'red', 'blue']




```python
colur=["yellow","purple","red","blue"]
colur.reverse()
colur
```




    ['blue', 'red', 'purple', 'yellow']



#### 遍历整个列表（range（））

你经常需要遍历列表的所有元素，对每个元素执行相同的操作

需要对列表中的每个元素都执行相同的操作时，可使用Python中的for循环。


```python
#下面使用for循环来打印名单中的所有名字：
names = ['Linda','alice', 'david', 'carolina']
for i in names:
    print(i,end="\t")
```

    Linda	alice	david	carolina	

#### 序列类型的应用场景

序列包含元组，列表2中重要的扩展类型

序列类型最主要的是用来做数据场景

**其中元组用于不改变的应用场景，更多用于固定搭配场景（如：函数返回值return）**

列表更加灵活，它是常用的序列类型

最主要作用：表示一组有序数组，进而操作它们


**数据遍历**

for item in ls:

    <语句块>
    
    
**数据保护**

如果不希望数据被程序所修改，转化成元组类型




```python
#如下：将列表变成为元组，这样数据就不会被修改
colur=["yellow","purple","red","blue"]
tuple(colur)
```




    ('yellow', 'purple', 'red', 'blue')



## 序列类型及操作（总结）

序列是基类类型，扩展类包括：字符串，元组，列表

其中元组用()和tuple()创建，列表用[]和list()创建

元组操作与序列操作基本相同

列表操作在序列操作基础上，增加了更多的灵活性



**基本统计值概要**

给出一组数据，对它们有个概要理解

如：总个数，求和，方差，中位数...

**基本统计值**

总个数: len(x)

求和：for...in

平均值：求和/总个数

方差：个数据与平均数差的平方的和的平均数

中位数：排顺序，然后 奇数找中间一个，偶数找中间2个取平均



```python
#获取数据
def getNum():
    nums=[]
    iNumStr=input("请输入数字（回车退出）：")
    
    while iNumStr !="":
        nums.append(eval(iNumStr))
        iNumStr=input("请输入数字（回车推退出）：")
    return nums


#数据求和
def mean(numbers): 
    s=0.0
    for num in numbers:
        s = s + num
    return s/len(numbers)


# 方差的计算
def dev(numbers,mean):    
    sdev=0.0
    for num in numbers:
        sdev=sdev+(num-mean)**2 
    return pow(sdev/(len(numbers)-1),0.5)


#计算中位数
def median(numbers):
    sorted(numbers)
    size=len(numbers) 
    if size % 2==0:
        med=(numbers[size//2-1]+numbers[size//2])/2
    else:
        med=numbers[size//2]
    return med

n=getNum()
m=mean(n)
print("均值{}方差：{}中位数{}".format(m,dev(n,m),median(n)))
```

    请输入数字（回车退出）：23
    请输入数字（回车推退出）：34
    请输入数字（回车推退出）：
    均值28.5方差：7.7781745930520225中位数28.5
    

技术能力扩展

获取多个数据：

分割多个函数：模块化设计方法

充分利用函数



### 对数字列表执行简单的统计计算

有几个专门用于处理数字列表的Python函数。                         
例如，你可以轻松地找出数字列表的最大值、最小值和总和：函数分别是 max(),min(),sum()


```python
list=(12,35,67,87)
print(max(list),min(list),sum(list),end="\n")
```

    87 12 201
    


```python
list=(12,35,67,87,35)
type(list)
```




    tuple



#### 列表解析
列表解析让你只需编写一行代码就                
能生成这样的列表。列表解析将for循环和创建新元素的代码合并成一行，并自动附加新元素。


```python
box=[x**2 for x in range(11)]
print(box)
#这个表达式，我也是第一次接触，也要刻在脑子中
```

    [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
    

## 字典类型及操作

字典类型的定义：

**映射**

映射是一种键（索引）和值（数据）的对应

可以理解为索引就是键，数据就是要值

如日常生活中：

    city：Beijing
    
    colour：purple
    
字典类型是映射的体现：

键值对：键是数据索引的扩展

字典是键值对的集合，键值对之间无序

在Python语言中采用大括号{}和dict()创建，键值对用冒号表示

{<键1>:<值1>，<键2>:<值2>，<键n>:<值n>}

**如下**
    
    <字典变量>={<键1>:<值1>，<键2>:<值2>，<键n>:<值n>}
    
    <值>=<字典变量><键>   or   <字典变量><键>=<值>
    
    
   []用来向字典变量中增加键值对

你可以创建一个表示人的字典，然后想在其中存储多少信息就存储多少信息：

姓名、年龄、地址、职业以及要描述的任何方面。

你还能够存储任意两种相关的信息，如一系列单词及其含义，

一系列人名及其喜欢的数字，以及一系列山脉及其海拔等。

## 一个简单的字典

与大多数编程概念一样，要熟练使用字典，也需要一段时间的练习。使用字典一段时间后，

你就会明白为何它们能够高效地模拟现实世界中的情形。

键—值对是两个相关联的值。指定键时，Python将返回与之相关联的值。

键和值之间用冒号分隔，而键—值对之间用逗号分隔。在字典中，你想存储多少个键—值对都可以。


```python
#举个栗子  存储一个用户名和密码的字典 如下：
#在Python中，字典用放在花括号{}中的一系列键—值对表示，如前面的示例所示：
User_informations={'Tom':3323,'Bob':'00324',"Linda":55443}
print(User_informations)
```

    {'Tom': 3323, 'Bob': '00324', 'Linda': 55443}
    


```python
d= {'中国':'北京','日本':'东京','韩国':'首尔'}
d
```




    {'中国': '北京', '日本': '东京', '韩国': '首尔'}




```python
d= {'中国':'北京','日本':'东京','韩国':'首尔'}
d['日本']
```




    '东京'



### 访问字典中的值


```python
#要获取与键相关联的值，可依次指定字典名和放在方括号内的键，如下所示：
User_informations={'Tom':3323,'Bob':'00324',"Linda":55443}
print(User_informations['Tom'])
print("\nTom的密码是：{}".format(User_informations['Tom']))
```

    3323
    
    Tom的密码是：3323
    

### 添加键—值对

字典是一种动态结构，可随时在其中添加键—值对。要添加键—值对，可依次指定字典名、用 方括号括起的键和相关联的值。


```python
User_informations={'Tom':3323,'Bob':'00324',"Linda":55443}
print(User_informations)

#新增2个键值对
User_informations['Jack']=3456
User_informations['Lilei']=6654
print(User_informations)
#可以看到输出后新增加了2个键值对 如下输出：
```

    {'Tom': 3323, 'Bob': '00324', 'Linda': 55443}
    {'Tom': 3323, 'Bob': '00324', 'Linda': 55443, 'Jack': 3456, 'Lilei': 6654}
    

   这个字典的最终版本包含四个键—值对，键—值对的排列顺序与添加顺序不同。          
   Python不关心键—值对的添加顺序，而只关心键和值之间的关联关系。

### 先创建一个空字典
有时候，在空字典中添加键—值对是为了方便，而有时候必须这样做。

为此，可先使用一对 空的花括号定义一个字典，再分行添加各个键—值对。

例如，下例演示了如何以这种方式创建字典


```python
Cars={} #创建字典用大括号
print(type(Cars))  #查看集合类型
#下面2句话是将在空的字典里建立2个键值对
Cars['Aodi']=200000
Cars['Bmw']=1000000
#打印字典
print(Cars) 
```

    <class 'dict'>
    {'Aodi': 200000, 'Bmw': 1000000}
    

### 修改字典中的值

要修改字典中的值，可依次指定字典名、用方括号括起的键以及与该键相关联的新值。


```python
User_informations={'Tom':3323,'Bob':'00324',"Linda":55443}
#Next we will change ‘Tom’s password and Linda's password
#为了更好的展示，我们把他们的密码都设置为字母
#修改如下：
print('变更前的'+str(User_informations))
User_informations['Tom']='Hello'
User_informations['Linda']='purple'
print('变更后的'+str(User_informations))
```

    变更前的{'Tom': 3323, 'Bob': '00324', 'Linda': 55443}
    变更后的{'Tom': 'Hello', 'Bob': '00324', 'Linda': 'purple'}
    

### 删除键—值对 (del)

对于字典中不再需要的信息，可使用del语句将相应的键—值对彻底删除。使用del语句时， 必须指定字典名和要删除的键。


```python
User_informations={'Tom': 'Hello', 'Bob': '00324', 'Linda': 'purple'} 
del User_informations['Tom'] #注意：删除的键—值对永远消失了。
print(User_informations)
```

    {'Bob': '00324', 'Linda': 'purple'}
    

### 遍历字典

探索各种遍历方法前，先来看一个新字典，它用于存储有关网站用户的信息。下面的字典存 储一名用户的用户名、名和姓：
### 遍历字典中的所有键值对



```python
user_0 = {
'username': 'efermi',
'first': 'enrico',
'last': 'fermi',
}
for key,value in user_0.items():
    print('\nkey'+key)
    print("value"+value)
```

    
    keyusername
    valueefermi
    
    keyfirst
    valueenrico
    
    keylast
    valuefermi
    

一个Python字典可能只包含几个键—值对，也可能包含数百万个键—值对。

鉴于字典可能包含 大量的数据，Python支持对字典遍历。字典可用于以各种方式存储信息

因此有多种遍历字典的 方式：可遍历字典的所有键—值对、键或值。


```python
User_informations={'Tom':3323,'Bob':'00324',"Linda":55443}
for key,value in User_informations.items():
    print(key,value)
```

    Tom 3323
    Bob 00324
    Linda 55443
    

### 遍历字典中的所有键 (keyes())

在不需要使用字典中的值时，方法keys()很有用。

遍历字典时，会默认遍历所有的键，因此，

如果将上述代码中的for i in User_informations.keys():替换为for i in User_informations:，输出将不变。 

如果显式地使用方法keys()可让代码更容易理解，你可以选择这样做，但如果你愿意，也可 省略它。



```python
#方法一 使用keys  ==========>这种方法比较清楚的表达，当然你用方法二也是可以的

User_informations={'Tom':3323,'Bob':'00324',"Linda":55443}
for i in User_informations.keys():
    print(i)
    
    
    #print(i.upper())  #这里是将元素的key全部大写输出，
    #还记的第三章讲过的字符串的处理吗：upper，lower，title
```

    Tom
    Bob
    Linda
    


```python
#方法二：
for i in User_informations:
    print(i.upper()) #复习前面的内容 upper
```

    TOM
    BOB
    LINDA
    

### 遍历字典中的所有值

如果你感兴趣的主要是字典包含的值，可使用方法values()，它返回一个值列表，而不包含 任何键。


```python
User_informations={'Tom':3323,'Bob':'00324',"Linda":55443}
for i in User_informations.values():
    print (i,end="\t")
```

    3323	00324	55443	


```python
#想在我们再深入的想一下 怎么把values变成一个list？
#建立一个空list
User_informations={'Tom':3323,'Bob':'00324',"Linda":55443}
Values=[]
for i in User_informations.values():
    Values.append(i)  #这里就是
print(Values)
```

    [3323, '00324', 55443]
    


```python
# ①list中有重复项
#我们修改如下字典中的‘Tom’和‘Linda’的Value是相同时，看看输出的list时什么
User_informations={'Tom':3323,'Bob':'00324',"Linda":3323}
Values=[]
for i in User_informations.values():
    Values.append(i)  #这里就是之前讲过的append（）===>复习
print(Values)
```

    [3323, '00324', 3323]
    

这种做法提取字典中所有的值，而没有考虑是否重复。

涉及的值很少时，这也许不是问题， 但如果很多呢？最终的列表可能包含大量的重复项。

**为剔除重复项，可使用集合（set）。**

集合类似于列表，但每个元素都必须是独一无二的：

看到输出的list中有重复的元素，那么如果要去掉重复值的话，该怎么处理？

元组、列表、集合、字典的区别https://www.cnblogs.com/maruobo/p/9669463.html

### 字典函数处理方法

|函数or方法|描述|
|-----|-----|
|del d[k]|删除字典d中键k对应的数据值|
|k in d|判断k是否在字典d中，如果在返回True，反则 False|
|d.keys()|返回字典d中所有键的信息|
|d.values()|返回字典d中所有值的信息|
|d.item()|返回字典d中所有键值对的信息|
|d.get(k, <default>) |键k存在，返回对应的值，不在则返回<default>值|
|d.pop(k, <default>) |键k存在，取出对应的值，不在则返回<default>值|
|d.popitem()|随机从字典中取出一个键值对，以元组形式返回|
|d.clear()|删除所有键值对|
|len(d)|返回字典d中元素的个数|


```python
#②剔除重复项
User_informations={'Tom':3323,'Bob':'00324',"Linda":3323}
Values=[]
#使用set剔除重复项
for i in set(User_informations.values()):
    Values.append(i)
print(Values)
#可以对比①和②的区别，根据自己的需求进行选择 
```

    [3323, '00324']
    

### 字典类型的应用场景（总结）

**映射表达**

映射无处不在，键值对无处不在

如：统计出现次数，数据时键，次数是值

最主要作用：表达键值对，进行操作它们

字典类型使用{}和dict()创建，键值对之间用：分割

d[key]方式可以索引，也可以赋值

字典类型有一批操作方法和函数，重要的是.get()

## 嵌套

有时候，需要将一系列字典存储在列表中，或将列表作为值存储在字典中，这称为嵌套。

你可以在列表中嵌套字典、在字典中嵌套列表甚至在字典中嵌套字典。

正如下面的示例将演示的， 嵌套是一项强大的功能。

### 字典列表

这里我还没有找到一个好一点的栗子[捂脸]

###  在字典中储存list

### 在字典中储存字典



```python
#这个程序要好好研究一哈  字典应用比较全面
users = {
    'aeinstein':{ 'first': 'albert','last': 'einstein','location': 'princeton'},
    
    'mcurie':{'first': 'marie','last': 'curie','location': 'paris'}
}


for username, user_info in users.items():
    print("\nusername:"+username)
    full_name=user_info['first']+user_info["last"]
    location=user_info['location']
    
    print("\tfull_name:"+full_name.title())
    print("\tlocation:"+location)
```

    
    username:aeinstein
    	full_name:Alberteinstein
    	location:princeton
    
    username:mcurie
    	full_name:Mariecurie
    	location:paris
    


```python
#再来写一个
people={
    'Tom':{'age':23,'gender':"boy",'height':168},
    "Linda":{'age':25,'gender':'girl','height':166}
}


for name,information in people.items():
    print("\n{}'s age is:{},gender is:{},Height is:{}" \
        .format(name,information['age'], \
        information['gender'],information['height']))
    #一行写的真长，不建议这样做 如果真的需要写这么长的code
    #这建议换行 [空格]+'\'
    #应该看的懂吧
```

    
    Tom's age is:23,gender is:boy,Height is:168
    
    Linda's age is:25,gender is:girl,Height is:166
    


```python
d= {'中国':'北京','日本':'东京','韩国':'首尔'}
"中国" in d
```




    True




```python
d= {'中国':'北京','日本':'东京','韩国':'首尔'}
d.keys()

d.values()
```




    dict_values(['北京', '东京', '首尔'])




```python
d= {'中国':'北京','日本':'东京','韩国':'首尔'}
a=d.items()
a=tuple(a)
a[1]
```




    ('日本', '东京')




```python
d= {'中国':'北京','日本':'东京','韩国':'首尔'}
a=d.get('中国')
print(a)
```

    北京
    

# jieba 库的使用（非常优秀的中文分词库）

中文文本需要通过分词获得单个的词语

jieba是非常优秀的第三方库，需要额外安装（在cmd模式下: “pip install jieba”即可）需连接互联网

jieba库提供了三种分词模式（精确模式，全模式，搜索引擎模式） 只需要掌握一个函数就好了

## jieba分词原理

jieba分词依靠中文词库

汉字间概率大的组成词组，形成分词结果

除了分词用户也可以添加自定义词组

## jieba库使用说明

jieba库提供了三种分词模式（精确模式，全模式，搜索引擎模式）

精确模式：把文本精确的切开，不存在冗余单词（比较常用）

全模式：把文本中所有可能的词语都扫描出来，有冗余

搜索引擎模式：在精确模式基础上，对长词再次切分


## jieba 常用函数（4个）

|函数|描述|
|-----|-----|
|jieba.lcut(s)|精确模式，返回一个列表类型的精确结果（l：list；cut）|
|jiba.lcut(s,cut_all=True)|全模式，返回一个列表类型的分词结果，存在冗余|
|jieba.lcut_for_search(s)|搜索引擎模式，返回一个列表类型的结果，存在冗余|
|jieba.add_word(w)|向分词字典添加新词w|



```python
import jieba
jieba.lcut("我是非著名业余程序员")
```




    ['我', '是非', '著名', '业余', '程序员']




```python
import jieba
jieba.lcut_for_search("我是非著名业余程序员")
```




    ['我', '是非', '著名', '业余', '程序', '程序员']




```python
import jieba
jieba.lcut("我是非著名业余程序员",cut_all=True)
```




    ['我', '是非', '著名', '业余', '余程', '程序', '程序员']



## 文件和数据格式化

数据格式化：将一组数据按照一定的规格和样式进行规范：表示，储存，运算等！

### 文件的类型

文件是储存在辅助存储器上的数据序列

文件是数据储存的一种形式

文件展现形态：文本文件和二进制文件

### 文件的打开 和关闭

文件的操作：打开-操作-关闭

<变量名名>=open(<文件名>，<打开模式>)  #<文件名>文件路径和名称（源文件同目录可缺省路径）

|文件的打开模式|描述|
|-----|-----|
|'r'|只读模式,默认值，如果文件不存在，则返回FileNotFoundError|
|'w'|覆盖写模式，文件不存在创建，文件存在覆盖|
|'x'|创建写模式，如果文件不存在，则返回FileExistsError|
|'a'|追加写模式，文件不存在创建，存在则在文件后面追加内容|
|'b'|二进制文件模式|
|'t'|文本文件模式，默认值|
|'+'|与r/w/x/a一同使用，在原功能基础上增加同时读写功能|




f= open("txt.txt") #文本形式，只读模式，默认值

f= open("txt.txt","rt") #本形式，只读模式,同默认值

f= open("txt.txt","w") #文本形式，覆盖写模式

f= open("txt.txt","a+") #文本形式，追加写模式+读文件

f= open("txt.txt","x") #文本形式，创建写模式

f= open("txt.txt","b")#二进制形式，只读模式

f= open("txt.txt","'wb") #二进制形式，覆盖写模式



#### **文件关闭**

<变量名>.close()

#### 文件内容的读取

a.read(size)

a.readline(size)

a.readlines(hint)



#### 数据的文件写入

a.write(s)

a.writelines(lines)

a.seek(offset)

### 文件和数据的处理

#### 以为数据的格式化和处理

数据组织的维度

**一维数据的表示**

一维数据由对等关系的有序or无序数据构成，采用线性方式组织

二维数据：由多个一维数据构成，是一维数据的组合形式

多维数据：由一维or二维数据在新维度上扩展形成

如果数据间有序，使用列表类型

    如：ls=["234",345,"590"]
    
如果数据之间没有顺序，我们可以用集合来表示

st={"sdf","ewr3","765","fhy6"}

集合类型可表达一维无序列数据

一维数据的储存

一维数据的处理




### 文件和异常
####  从文件中读取数据

文本文件可存储的数据量多得难以置信：天气数据、交通数据、社会经济数据、文学作品等。 每当需要分析或修改存储在文件中的信息时，读取文件都很有用，对数据分析应用程序来说尤其 如此。例如，你可以编写一个这样的程序：读取一个文本文件的内容，重新设置这些数据的格式 并将其写入文件，让浏览器能够显示这些内容。 要使用文本文件中的信息，首先需要将信息读取到内存中。为此，你可以一次性读取文件的 全部内容，也可以以每次一行的方式逐步读取。
####  读取整个文件

要读取文件，需要一个包含几行文本的文件。下面首先来创建一个文件，它包含精确到小数 点后30位的圆周率值，且在小数点后每10位处都换行：

将该文件保存到本章程序所在的目录中。 地址：C:\Users\QUESTERYU.ipynb_checkpoints 根据自己的电脑进行查找 下面的程序打开并读取这个文件，再将其内容显示到屏幕上：


3.1415926535

8979323846

2643383279

保存为text.txt 将该文件保存到本章程序所在的目录中。



```python
with open(r'C:\Users\QUESTERYU\.ipynb_checkpoints\text.txt') as file_object:
    contents = file_object.read()
    print(contents)
```

    3.1415926535   
       8979323846   
       2643383279
    
    
          
    

我们先来看看函数open()。要以任何方式使用 文件——哪怕仅仅是打印其内容，都得先打开文件，这样才能访问它。函数open()接受一个参数： 要打开的文件的名称。

在这个示例中， 当前运行的是这个程序，因此Python在这个程序所在的目录中查找text.txt。函数open() 返回一个表示文件的对象。在这里，open('C:\Users\QUESTERYU.ipynb_checkpoints\text.txt') 返回一个表示文件text.txt的对象；Python将这个对象存储在我们将在后面使用的变量中。

关键字with在不再需要访问文件后将其关闭。在这个程序中，注意到我们调用了open()，但 没有调用close()；你也可以调用open()和close()来打开和关闭文件，但这样做时，如果程序存 在bug，导致close()语句未执行，文件将不会关闭。这看似微不足道，但未妥善地关闭文件可能 会导致数据丢失或受损。如果在程序中过早地调用close()，你会发现需要使用文件时它已关闭 （无法访问），这会导致更多的错误。并非在任何情况下都能轻松确定关闭文件的恰当时机，但通 过使用前面所示的结构，可让Python去确定：你只管打开文件，并在需要时使用它，Python自会 在合适的时候自动将其关闭。


相比于原始文件，该输出唯一不同的地方是末尾多了一个空行。为何会多出这个空行呢？因
为read()到达文件末尾时返回一个空字符串，而将这个空字符串显示出来时就是一个空行。要删
除多出来的空行，可在print语句中使用rstrip()：
为何会出现这些空白行呢？因为在这个文件中，每行的末尾都有一个看不见的换行符，而
print语句也会加上一个换行符，因此每行末尾都有两个换行符：一个来自文件，另一个来自print
语句。


```python
with open(r'C:\Users\QUESTERYU\.ipynb_checkpoints\text.txt') as text:
    text=text.read()
    print(text.rstrip())
```

    3.1415926535   
       8979323846   
       2643383279
    

####  文件路径

要让Python打开不与程序文件位于同一个目录中的文件，需要提供文件路径，它让Python到系统的特定位置去查找。

上面的一章调用过文件路径=========>r'C:\Users\QUESTERYU\.ipynb_checkpoints\text.txt'

就是这个样子的
在Windows系统中，在文件路径中使用反斜杠（\）而不是斜杠（/）
绝对路径通常比相对路径更长，因此将其存储在一个变量中，再将该变量传递给open()会有所帮助。


刚刚在运行python文件的时候竟然报SyntaxError: (unicode error) 'unicodeescape' codec can't decode bytes in position 2-3: tr这个错误，其实引起这个错误的原因就是转义的问题。


```python
with open('C:\Users\QUESTERYU\.ipynb_checkpoints\text.txt') as text:
    text=text.read()
    print(text.rstrip())
```


      File "<ipython-input-266-58e0eb71ff5b>", line 1
        with open('C:\Users\QUESTERYU\.ipynb_checkpoints\text.txt') as text:
                 ^
    SyntaxError: (unicode error) 'unicodeescape' codec can't decode bytes in position 2-3: truncated \UXXXXXXXX escape
    


**原因分析：**在windows系统当中读取文件路径可以使用,但是在python字符串中\有转义的含义，如\t可代表TAB，\n代表换行，所以我们需要采取一些方式使得\不被解读为转义字符。目前有3个解决方案


```python
#1、在路径前面加r，即保持字符原始值的意思。
with open(r'C:\Users\QUESTERYU\.ipynb_checkpoints\text.txt') as text:
    text=text.read()
    print(text.rstrip())
```

    3.1415926535   
       8979323846   
       2643383279
    


```python
#2、替换为双反斜杠
with open('C:\\Users\\QUESTERYU\\.ipynb_checkpoints\\text.txt') as text:
    text=text.read()
    print(text.rstrip())
    print(text)
    print(len(text),len(text.rstrip()))
```

    3.1415926535   
       8979323846   
       2643383279
    3.1415926535   
       8979323846   
       2643383279
    
    
          
    55 46
    


```python
#3、替换为正斜杠
with open('C:/Users/QUESTERYU/.ipynb_checkpoints/text.txt') as text:
    text=text.read()
    print(text.rstrip())
```

    3.1415926535   
       8979323846   
       2643383279
    

**也可以将路径设置为变量 如下：**


```python
a='C:/Users/QUESTERYU/.ipynb_checkpoints/text.txt'
with open(a)as a:
    a=a.read()
    print(a)
    print(a.rstrip()) #去除尾部的空格
```

    3.1415926535   
       8979323846   
       2643383279
    
    
          
    3.1415926535   
       8979323846   
       2643383279
    

#### 逐行读取

读取文件时，常常需要检查其中的每一行：你可能要在文件中查找特定的信息，或者要以 某种方式修改文件中的文本。


```python
a='C:/Users/QUESTERYU/.ipynb_checkpoints/text.txt'

with open(a)as a:
    
    print(a.readlines(7))
```

    ['3.1415926535   \n']
    

 创建一个包含文件各行内容的列表

使用关键字with时，open()返回的文件对象只在with代码块内可用。如果要在with代码块外

访问文件的内容，可在with代码块内将文件的各行存储在一个列表中，并在with代码块外使用该

列表：你可以立即处理文件的各个部分，也可推迟到程序后面再处理。


```python
#下面的示例在with代码块中将文件pi_digits.txt的各行存储在一个列表中，再在with代码块外打印它们：
a='C:/Users/QUESTERYU/.ipynb_checkpoints/text.txt'
with open(a)as a:
    lines=a.readlines()
    
for line in lines:
    print(line.rstrip())
```

    3.1415926535
       8979323846
       2643383279
    
    
    
    

方法readlines()从文件中读取每一行，并将其存储在一个列表中；接下来，该列表被 存储到变量lines中；在with代码块外，我们依然可以使用这个变量。 我们使用一个简单 的for循环来打印lines中的各行。由于列表lines的每个元素都对应于文件中的一行，因此输出 与文件内容完全一致。

#### 使用文件的内容

将文件读取到内存中后，就可以以任何方式使用这些数据了。下面以简单的方式使用圆周率 的值。首先，我们将创建一个字符串，它包含文件中存储的所有数字，且没有任何空格：


```python
a='C:/Users/QUESTERYU/.ipynb_checkpoints/text.txt'
with open(a)as a:
    lines=a.readlines()
po='' #新建一个字符串用于储存文件中的字符
pe=''
pc=''
#这里我们复习一下关于字符串的处理 
#详见:删除空白字符串中的空格（rstrip(尾部),lstrip(首部),strip(首尾))
#我们分别打印看效果
for line in lines:
    po+=line.strip()
    pe+=line.rstrip()
    pc+=line.lstrip()
print("strip(首尾)po={},\nrstrip(尾部)pe={},\n\nlstrip(首部)pc={}" \
     .format(po,pe,pc))
print(len(po))
#上面全都是是字符串不能进行运算，如果想要变成数字，就要用int整性，float浮点数
```

    strip(首尾)po=3.141592653589793238462643383279,
    rstrip(尾部)pe=3.1415926535   8979323846   2643383279,
    
    lstrip(首部)pc=3.1415926535   
    8979323846   
    2643383279
    
    32
    


```python
#我们下载一个百万级的圆周率，看看里面有没有自己的生日
t='C:\\Users\QUESTERYU\\.ipynb_checkpoints\\pi_million.txt'
with open(t) as t:
    lines=t.readlines()
pi=''
for line in lines:
    pi+=line.strip()  #每一行的首尾去掉空格
boriday=input("please you input you're boriday:")
if boriday in pi:
    print('yes')
else:
    print('No')  
```

    please you input you're boriday:1210
    yes
    

#### 写入文件

在这个示例中，调用open()时提供了两个实参。第一个实参也是要打开的文件的名称； 第二个实参（'w'）告诉Python，我们要以写入模式打开这个文件。打开文件时，可指定读取模 式（'r'）、写入模式（'w'）、附加模式（'a'）或让你能够读取和写入文件的模式（'r+'）。如果 你省略了模式实参，Python将以默认的只读模式打开文件。 如果你要写入的文件不存在，函数open()将自动创建它。然而，以写入（'w'）模式打开文 件时千万要小心，因为如果指定的文件已经存在，Python将在返回文件对象前清空该文件


```python
import os   
t='miss.txt'
with open (t,'w') as t:
    t.write("I miss U")
print(os.getcwd())

with open("miss.txt","r")as t:
    print("我们写入的文件为：{}".format(t.read()))
```

    C:\Users\QUESTERYU
    我们写入的文件为：I miss U
    


```python
#也可以写入多行字符串 如下：（就上面的代码，换一种方式写一下，实践一下条条大路通罗马
with open ("miss.txt",'w')as t:
    t.write("\n大家好")
    t.write("\nnimasan")
#如果文件存在，以写入（'w'）模式打开文 件时千万要小心，
#因为如果指定的文件已经存在，Python将在返回文件对象前清空该文件。切记！！！切记！！！
```


```python
#接下来我们打印出文本中的字符
with open ("miss.txt",'w')as t:
    t.write("\n大家好")
    t.write("\nnimasan")
    
#我们再次去读取文件中的字符串（这里还有没有更简单的方法呢？）
#if True，please tell me
with open ('miss.txt','r')as C:
    lines=C.readlines()
for line in lines:
    print(line)
```

    
    
    大家好
    
    nimasan
    

#### 附加到文件 （附加模式'a')

**如果你要给文件添加内容，而不是覆盖原有的内容，可以附加模式打开文件。**

你以附加模式 打开文件时，Python不会在返回文件对象前清空文件，而你写入到文件的行都将添加到文件末尾。

如果指定的文件不存在，Python将为你创建一个空文件。


```python
#以上面的“miss.txt文件为栗子
with open('miss.txt','a') as re:
    re.write("\n你好Questeryu\t")
    re.write("yu")
    
with open('miss.txt','r') as f:
    a=f.readlines()
for i in a:
    print(i)
```

    
    
    大家好
    
    nimasan
    
    你好Questeryu	yu
    

## 异常

Python使用被称为异常的特殊对象来管理程序执行期间发生的错误。每当发生让Python不知 所措的错误时，它都会创建一个异常对象。如果你编写了处理该异常的代码，程序将继续运行； 如果你未对异常进行处理，程序将停止，并显示一个traceback，其中包含有关异常的报告。 异常是使用try-except代码块处理的。try-except代码块让Python执行指定的操作，同时告 诉Python发生异常时怎么办。使用了try-except代码块时，即便出现异常，程序也将继续运行： 显示你编写的友好的错误消息，而不是令用户迷惑的traceback。


### 处理ZeroDivisionError 异常

导致Python引发异常的简单错误。你可能知道不能将一个数字除以0，但我们 还是让Python这样做吧：


```python
print(33/0)
```


    ---------------------------------------------------------------------------

    ZeroDivisionError                         Traceback (most recent call last)

    <ipython-input-279-effb1e335121> in <module>
    ----> 1 print(33/0)
    

    ZeroDivisionError: division by zero


错误**ZeroDivisionError**是一个异常对象。

Python无法按你的 要求做时，就会创建这种对象。

在这种情况下，Python将停止运行程序，并指出引发了哪种异常， 而我们可根据这些信息对程序进行修改。

下面我们将告诉Python，发生这种错误时怎么办；这样， 如果再次发生这样的错误，我们就有备无患了。

### 使用try-except 代码块（前面讲过）


```python
try:
    print(33/0)
except ZeroDivisionError:
    print("You can't divide by zero!")
```

    You can't divide by zero!
    

如果try代码块中的代码运行 起来没有问题，Python将跳过except代码块；如果try代码块中的代码导致了错误，Python将查找 这样的except代码块，并运行其中的代码，即其中指定的错误与引发的错误相同。

如果try-except代码块后面还有其他代码，程序将接着运行，因为已经告诉了Python如何处 理这种错误


### 存储数据

很多程序都要求用户输入某种信息，程序都把用户提供的信息存储在列表和字典等数据结构中。用户关闭程序时，你 几乎总是要保存他们提供的信息；一种简单的方式是使用模块json来存储数据。
####  使用json.dump()和json.load()

我们来编写一个存储一组数字的简短程序，再编写一个将这些数字读取到内存中的程序。第 一个程序将使用json.dump()来存储这组数字，而第二个程序将使用json.load()。 函数json.dump()接受两个实参：要存储的数据以及可用于存储数据的文件对象。

import json numbers = [2, 3, 5, 7, 11, 13] test='numbers.json'

#我们指定了要将该数字列表存储到其中的文件的名称。

#通常使用文件扩展名.json来指出文件存储的数据为JSON格式。

#接下来，我们以写入模式打开这个文件，让json能够将数据写入其中。

#我们使用函数json.dump()将数字列表存储到文件numbers.json中。 with open('test','w') as re: json.dump(numbers,re)



```python
#下面再编写一个程序，使用json.load()将这个列表读取到内存中：
import json
test='numbers.json'
with open(r"C:\Users\QUESTERYU\test") as t:
    numbers = json.load(t)
print(numbers)
```

    [2, 3, 5, 7, 11, 13]
    

#### 保存和读取用户生成的数据


```python
import json
name=input('请输入你的名字')
#username='name.json'
with open('user_name','w') as re:
    json.dump(name,re)
    print('you are name is '+name)
```

    请输入你的名字Questeryu
    you are name is Questeryu
    

## 关于 wordcloud 词云库

### 概述

wordcloud是优秀的词云展示第三方库，以词语为基本单位，通过图形可视化的方式，更加直观和艺术的展示文本。

### 基本使用

wordcloud 库把词云当作一个WordCloud对象

    wordcloud.WordCloud()代表一个文本对应的词云
    可以根据文本中词语出现的频率等参数绘制词云
    绘制词云的形状、尺寸和颜色均可设定
    以WordCloud对象为基础，配置参数、加载文本、输出文件

w= wordcloud.WordCloud()

|方法 |	描述|
|-----|------|
|w.generate() |	向WordCloud对象中加载文本txt|
||>>>w.generate("Python and WordCloud")|
|w.to_file(filename)| 	将词云输出为图像文件，.png或.jpg格式|
||>>>w.to_file("outfile.png")|


```python
import wordcloud
c=wordcloud.WordCloud()            #1.配置对象参数
c.generate("wordcloud by python")  #2.加载词云文本
c.to_file("pywordcloud.png")       #3.输出词云文件
```




    <wordcloud.wordcloud.WordCloud at 0x24ef7d61e88>



### **wordcloud如何将文本转化为词云**

    1.分隔：以空格分隔单词
    2.统计：单词出现次数并过滤
    3.字体：根据统计配置字号
    4.布局：颜色环境尺寸


#### **配置对象参数**

w= wordcloud.WordCloud(<参数>)

|参数 |	描述|
|-----|-----|
|width |指定词云对象生成图片的宽度,默认400像素|
||w=wordcloud.WordCloud(width=600)|
|height| 	指定词云对象生成图片的高度,默认200像素|
||w=wordcloud.WordCloud(height=400)|
|min_font_size| 	指定词云中字体的最小字号，默认4号|
||w=wordcloud.WordCloud(min_font_size=10)|
|max_font_size| 	指定词云中字体的最大字号，根据高度自动调节|
||w=wordcloud.WordCloud(max_font_size=20)|
|font_step |	指定词云中字体字号的步进间隔，默认为1|
||w=wordcloud.WordCloud(font_step=2)|
|font_path |	指定文体文件的路径，默认None|
||w=wordcloud.WordCloud(font_path="msyh.ttc")|
|max_words| 	指定词云显示的最大单词数量,默认200|
||w=wordcloud.WordCloud(max_words=20)|
|stop_words |	指定词云的排除词列表，即不显示的单词列表|
||w=wordcloud.WordCloud(stop_words="Python")|
|mask 	|指定词云形状，默认为长方形，需要引用imread()函数|
||from scipy.msc import imread|
||mk=imread("pic.png")|
||w=wordcloud.WordCloud(mask=mk)|
|background_color |	指定词云图片的背景颜色，默认为黑色|
||w=wordcloud.WordCloud(background_color="white")|

#### **应用实例**


```python
import wordcloud
txt ="life is short,you need python"
w=wordcloud.WordCloud(background_color="white")
w.generate(txt)
w.to_file("pywcloud.png")
```




    <wordcloud.wordcloud.WordCloud at 0x24efeb6bd08>



# 函 数

要执行函数定义的特定任务，可调用该函数。

需要在程序中多次 执行同一项任务时，你无需反复编写完成该任务的代码，而只需调用 执行该任务的函数，

让Python运行其中的代码。你将发现，通过使用 函数，程序的编写、阅读、测试和修复都将更容易。


```python
#其实也相当于子程序，接下来我们写一个函数，并且调用子程序并打印输出
def nihao():
    print("hello Questeryu")
#上面开头"def"告知Python定义一个函数    
nihao()
```

    hello Questeryu
    

## 定义一个函数

下面是一个打印问候语的简单函数，名为greet_user()：


```python
def greet_user():
    """显示简单的问候语"""
    print("Hello!")
greet_user()
```

    Hello!
    

这个示例演示了最简单的函数结构。

①处的代码行使用关键字def来告诉Python你要定义一个 函数。这是函数定义，向Python指出了函数名，还可能在括号内指出函数为完成其任务需要什么 样的信息。

在这里，函数名为greet_user()，它不需要任何信息就能完成其工作，因此括号是空 的（即便如此，括号也必不可少）。最后，定义以冒号结尾。 紧跟在def greet_user():后面的所有缩进行构成了函数体。
    
②处的文本是被称为文档字符串 （docstring）的注释，描述了函数是做什么的。文档字符串用三引号括起，Python使用它们来生成 有关程序中函数的文档。 
    
代码行print("Hello!")（见③）是函数体内的唯一一行代码，greet_user()只做一项工作： 打印Hello!。 要使用这个函数，可调用它。函数调用让Python执行函数的代码。要调用函数，可依次指定 函数名以及用括号括起的必要信息，如④处所示。

由于这个函数不需要任何信息，因此调用它时 只需输入greet_user()即可。和预期的一样，它打印Hello!：

### 向函数传递信息


```python
#将上面的代码修改一下 ，让输出带有名字的函数
def greet_user(name): #在括号中传入一个name
    """显示简单的问候语"""
    print("Hello!"+name)
greet_user('Lisa')
#同样我们可以调用"Tom"
greet_user('tom')
```

    Hello!Lisa
    Hello!tom
    

### 实参和形参

前面定义函数greet_user()时，要求给变量username指定一个值。调用这个函数并提供这种 信息（人名）时，它将打印相应的问候语。 在函数greet_user()的定义中，变量username是一个形参——函数完成其工作所需的一项信 息。在代码greet_user('jesse')中，值'jesse'是一个实参。实参是调用函数时传递给函数的信 息。我们调用函数时，将要让函数使用的信息放在括号内。在greet_user('jesse')中，将实参 'jesse'传递给了函数greet_user()，这个值被存储在形参username中。

## 传递实参

鉴于函数定义中可能包含多个形参，因此函数调用中也可能包含多个实参。向函数传递实参 的方式很多，可使用位置实参，这要求实参的顺序与形参的顺序相同；也可使用关键字实参，其 中每个实参都由变量名和值组成；还可使用列表和字典。下面来依次介绍这些方式。

### 位置实参

你调用函数时，Python必须将函数调用中的每个实参都关联到函数定义中的一个形参。

为此， 最简单的关联方式是基于实参的顺序。这种关联方式被称为位置实参。 

为明白其中的工作原理，来看一个显示宠物信息的函数。这个函数指出一个宠物属于哪种动 物以及它叫什么名字，如下所示：


```python
def describe_pet(animal_type, pet_name):
    """显示宠物的信息"""
    print("\nI have a " + animal_type + ".")
    print("My " + animal_type + "'s name is " + pet_name.title() + ".")
describe_pet('hamster', 'harry')
```

    
    I have a hamster.
    My hamster's name is Harry.
    


```python
def sun(a,b):
    '''计算a+b的值，and a的b次方'''
    print('a+b的值是：'+str(a+b)+'\na的b次方是：'+str(pow(a,b))+'\n')
sun(3,2)
#你可以多次调用函数
sun(3,4)
#关键参数 如下：
sun(b=3,a=5)  
```

    a+b的值是：5
    a的b次方是：9
    
    a+b的值是：7
    a的b次方是：81
    
    a+b的值是：8
    a的b次方是：125
    
    


```python
def sun(a=2,b=5):  #这里这个值定义一个默认值 当调用sun（）函数时候，默认输出如下：
    '''计算a+b的值，and a的b次方'''
    print('a+b的值是：'+str(a+b)+'\na的b次方是：'+str(pow(a,b))+'\n')
sun(3,2)
#默认输出
sun() #=============>这个就是默认值sun(a=2,b=5)
```

    a+b的值是：5
    a的b次方是：9
    
    a+b的值是：7
    a的b次方是：32
    
    

## 返回值

函数并非总是直接显示输出，相反，它可以处理一些数据，并返回一个或一组值。

函数返回 的值被称为返回值。在函数中，可使用return语句将值返回到调用函数的代码行。返回值让你能 够将程序的大部分繁重工作移到函数中去完成，从而简化主程序。

### 返回简单值


```python
def sum(a,b):
    c=a+b
    return c #这里就是返回值为c；
message=sum(3,5)
print(message)
```

    8
    

### 返回字典

函数可返回任何类型的值，包括列表和字典等较复杂的数据结构。例如，下面的函数接受姓 名的组成部分，并返回一个表示人的字典：


```python
def build_person(first_name, last_name):
    """返回一个字典，其中包含有关一个人的信息"""
    person = {'first': first_name, 'last': last_name}
    return person
musician = build_person('jimi', 'hendrix')
print(musician)
```

    {'first': 'jimi', 'last': 'hendrix'}
    


```python
def user_inf(user,password):
    '''记录用户的姓名和密码的字典'''
    person={user:password}
    return person
c=[]
user_inf('Tom',1234)
c.append(user_inf('Tom',1234))
print(c)
```

    [{'Tom': 1234}]
    

### 传递列表


```python
#写一个返回斐波那契数列的列表（而不是把它打印出来）的函数，非常简单:
def fib(n):
    """Return a list containing the Fibonacci series up to n."""
    result = []
    a,b=0,1
    while a<n:
        result.append(a)
        a,b=b,a+b
    return result 
fib100=fib(200)
print(fib100)
```

    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]
    

return 语句会从函数内部返回一个值。 不带表达式参数的 return 会返回 None。 函数执行完毕退出也会返回 None。

重要警告： 默认值只会执行一次。这条规则在默认值为可变对象（列表、字典以及大多数类实例）时很重要。比如，下面的函数会存储在后续调用中传递给它的参数:



```python
def f(a, L=[]):
    L.append(a)
    return L
print(f(2))
print(f(3))
print(f('nihao '))
```

    [2]
    [2, 3]
    [2, 3, 'nihao ']
    


```python
#如果你不想要在后续调用之间共享默认值，你可以这样写这个函数:
def f(a, L=[]):
    if L is not None:
        L=[]
    L.append(a)
    return L
print(f(3))
print(f('Ton'))
```

    [3]
    ['Ton']
    

### 解包参数列表

当参数已经在列表或元组中但要为需要单独位置参数的函数调用解包时，会发生相反的情况。

例如，内置的 range() 函数需要单独的 start 和 stop 参数。

如果它们不能单独使用，可以使用 *-操作符 来编写函数调用以便从列表或元组中解包参数:


```python
list(range(3,6)
print(list(range(3,6)))
```


      File "<ipython-input-308-da7d31066dc0>", line 2
        print(list(range(3,6)))
            ^
    SyntaxError: invalid syntax
    



```python
age=[3,6]
print(list(range(*age)))
```


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-309-6693b87be66d> in <module>
          1 age=[3,6]
    ----> 2 print(list(range(*age)))
    

    TypeError: 'tuple' object is not callable


# 类（这部份比较难点，I believe U can）

面向对象编程是最有效的软件编写方法之一。在面向对象编程中， 你编写表示现实世界中的事物和情景的类，并基于这些类来创建对象。 编写类时，你定义一大类对象都有的通用行为。基于类创建对象时， 每个对象都自动具备这种通用行为，然后可根据需要赋予每个对象独 特的个性。使用面向对象编程可模拟现实情景，其逼真程度达到了令 你惊讶的地步。

理解面向对象编程有助于你像程序员那样看世界，还可以帮助你真正明白自己编写的代 码：不仅是各行代码的作用，还有代码背后更宏大的概念。了解类背后的概念可培养逻辑思 维，让你能够通过编写程序来解决遇到的几乎任何问题。

## 创建和使用类

使用类几乎可以模拟任何东西。下面来编写一个表示girl friends——她表示的不是特定的GF，而是任何GF。 对于大多数GF，我们都知道些什么呢？首先如果你是一名正常男性，那么的你的对象应该是一名女性。

当然在程序的世界里我们必须要考虑其他的情况在里面，这里按照我这个年龄对这个对象概念的深了解

据说Facebook上面有30几种性别，真是大千世界，无奇不有啊！颠覆你的想象啊 哈哈哈 https://www.guokr.com/article/438003/
    
    如下：
    ① 女的 
    ②物理属型
    ③化学属性
    ④萝卜青菜各有所爱
    扯远了。。。。哈哈哈  不过类（Class）就是这个样子的呀

这个类让Python知道如何创建表示GF的对象。编写这个类后，我们将使用它来创建表示特定Girlfriend的实例



```python
class Girl_friend():
    '''一次模拟对象的小尝试'''
    def __init__(self, name, age):
        """初始化属性name and age"""
        self.name=name
        self.age=age    
    def person(self):
        """不知道了，概念不清"""
        print(self.name.title() + " is very 聪明.")       
    def people(self):
        """where？"""
        print(self.name.title() + " in world")
        
a=Girl_friend("Q",28)
print(a.name)
print(a.person())
print(a.people())
```

    Q
    Q is very 聪明.
    None
    Q in world
    None
    


```python
#接下来再来写一个吧，描写所computer（class）=========>那就写一个计算机吧
class Computer():
    '''描述一个是什么'''
    #一定要注意这里“__init__"这里左右两边各有2个"_"，不然会报错， \
    #很难找到的，我就在这里栽了跟头好几天
    def __init__(self,si,pr): 
        self.si=si
        self.pr=pr
    def Programe(self):
        '''计算机能干什么'''
        print("它可以帮助人们解决一些技术上面的问题")
    def da(self):
        '''它可以简化人们的工作'''
        print("它可以简化人们的工作")
        
liada=Computer("sa","da")
print(liada.si)
liada.da()
```

    sa
    它可以简化人们的工作
    

## 模拟实物

模拟较复杂的物件（如电动汽车）时，需要解决一些有趣的问题。 这让你进入了程序员的另一个境界：解决上述问题时，你从较高的逻辑层面（而不是语法层 面）考虑；你考虑的不是Python，而是如何使用代码来表示实物。到达这种境界后，你经常会发 现，现实世界的建模方法并没有对错之分。有些方法的效率更高，但要找出效率最高的表示法，需要经过一定的实践。只要代码像你希望的那样运行，就说明你做得很好！即便你发现自己不得 不多次尝试使用不同的方法来重写类，也不必气馁；要编写出高效、准确的代码，都得经过这样 的过程。

## 导入类

随着你不断地给类添加功能，文件可能变得很长，即便你妥善地使用了继承亦如此。为遵循 Python的总体理念，应让文件尽可能整洁。为在这方面提供帮助，Python允许你将类存储在模块 中，然后在主程序中导入所需的模块。
## 导入整个模块

你还可以导入整个模块，再使用句点表示法访问需要的类。这种导入方法很简单，代码也易 于阅读。由于创建类实例的代码都包含模块名，因此不会与当前文件使用的任何名称发生冲突。
## 导入模块中的所有类

要导入模块中的每个类，可使用下面的语法： from module_name import * 不推荐使用这种导入方式，其原因有二。首先，如果只要看一下文件开头的import语句，就 能清楚地知道程序使用了哪些类，将大有裨益；但这种导入方式没有明确地指出你使用了模块中 的哪些类。这种导入方式还可能引发名称方面的困惑。如果你不小心导入了一个与程序文件中其 他东西同名的类，将引发难以诊断的错误。这里之所以介绍这种导入方式，是因为虽然不推荐使 用这种方式，但你可能会在别人编写的代码中见到它。 需要从一个模块中导入很多类时，最好导入整个模块，并使用module_name.class_name语法 来访问类。这样做时，虽然文件开头并没有列出用到的所有类，但你清楚地知道在程序的哪些地 方使用了导入的模块；你还避免了导入模块中的每个类可能引发的名称冲突。
##  在一个模块中导入另一个模块

有时候，需要将类分散到多个模块中，以免模块太大，或在同一个模块中存储不相关的类。 将类存储在多个模块中时，你可能会发现一个模块中的类依赖于另一个模块中的类。在这种情况 下，可在前一个模块中导入必要的类。
## Python标准库

Python标准库是一组模块，安装的Python都包含它。你现在对类的工作原理已有大致的了解， 可以开始使用其他程序员编写好的模块了。可使用标准库中的任何函数和类，为此只需在程序开 头包含一条简单的import语句。下面来看模块collections中的一个类——OrderedDict。 字典让你能够将信息关联起来，但它们不记录你添加键—值对的顺序。要创建字典并记录其 中的键—值对的添加顺序，可使用模块collections中的OrderedDict类。OrderedDict实例的行为 几乎与字典相同，区别只在于记录了键—值对的添加顺序。
##  类编码风格

你必须熟悉有些与类相关的编码风格问题，在你编写的程序较复杂时尤其如此。 类名应采用驼峰命名法，即将类名中的每个单词的首字母都大写，而不使用下划线。实例名 和模块名都采用小写格式，并在单词之间加上下划线。 对于每个类，都应紧跟在类定义后面包含一个文档字符串。这种文档字符串简要地描述类的 功能，并遵循编写函数的文档字符串时采用的格式约定。每个模块也都应包含一个文档字符串， 对其中的类可用于做什么进行描述。 可使用空行来组织代码，但不要滥用。在类中，可使用一个空行来分隔方法；而在模块中， 可使用两个空行来分隔类。 需要同时导入标准库中的模块和你编写的模块时，先编写导入标准库模块的import语句，再 添加一个空行，然后编写导入你自己编写的模块的import语句。在包含多条import语句的程序中， 这种做法让人更容易明白程序使用的各个模块都来自何方。

最好的 Python 教程，是官方网站上的 The Python Tutorial，读它就够了。 其实Python官方教程写的很好的，李笑来老师建议都英文版的 这一章可以参见官方文档（中文）：https://docs.python.org/zh-cn/3/tutorial/index.html 谢谢！


# Python 程序设计思维


## 计算思维与程序设计

**逻辑思维：**推理和演绎，数学为代表： A//B, B//C  那么 A//C

**实证思维：**实验和验证，物理为代表：引力波<-实验

**计算思维：**设计和构造，计算机为代表，面向对象（递归）
 
 

**计算思维（Computational Thinking）**

    抽象问题的计算过程，利用计算机自动求解

    回顾历史，人类从结绳计数开始就有了计算的概念，并没有演绎出计算思维，只有计算机被广泛使用，

    计算机算力比人类更强大的设备时，计算思维才真正成为人类利用工具进行思维的一种方式



**计算生态与Python语言**

    开源思想深入演化和发展，形成了计算生态

    计算生态以开源项目为组织形式，充分利用“共识原则”和“社会利他”组织人员，在竞争发展、相互依存和迅速更迭中完成

    信息技术的更新换代，形成了技术的自我演化路径。


    以开源项目为代表的大量第三方库Python语言提供 >15万个第三方库；

    库的建设经过野蛮生长和自然选择同一个功能，Python语言2个以上第三方库；

    库之间相互关联使用，依存发展Python库间广泛联系，逐级封装；

    社区庞大，新技术更迭迅速AlphaGo深度学习算法采用Python语言开源；



**用户体验与软件产品**


编程只是手段，不是目的，程序最终为人类服务，所以我们要尽量考虑提高用户体验；

要是我们自己都不满意自己的产品，那么别人更加不会满意

**基本的程序设计模式**

    从IPO开始…
        确定IPO：明确计算部分及功能边界
        编写程序：将计算求解的设计变成现实
        调试程序：确保程序按照正确逻辑能够正确运行

    模块化设计
        通过函数或对象封装将程序划分为模块及模块间的表达
        具体包括：主程序、子程序和子程序间关系
        分而治之：一种分而治之、分层抽象、体系化的设计思想
        紧耦合：两个部分之间交流很多，无法独立存在
        松耦合：两个部分之间交流较少，可以独立存在
        模块内部紧耦合、模块之间松耦合

    配置化设计
        引擎+配置：程序执行和配置分离，将可选参数配置化
        将程序开发变成配置文件编写，扩展功能而不修改程序
        关键在于接口设计，清晰明了、灵活可扩展

    应用开发的四个步骤
    从应用需求到软件产品
        1 产品定义：对应用需求充分理解和明确定义
        产品定义，而不仅是功能定义，要考虑商业模式
        2 系统架构：以系统方式思考产品的技术实现
        系统架构，关注数据流、模块化、体系架构
        3 设计与实现：结合架构完成关键设计及系统实现
        结合可扩展性、灵活性等进行设计优化
        4 用户体验：从用户角度思考应用效果
        用户至上，体验优先，以用户为中心

# 安装Python第三方库

方法一：(主要方法)使用pip命令  （pip install <库名>）

    这里只需要记住这个：pip install -h（帮助文档）
方法二：集成安装方法

方法三：文件安装方法

**<center>Python总算入门了</center>**




```python

```
